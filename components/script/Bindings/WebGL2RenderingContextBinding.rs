/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */

#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

pub type GLint64 = i64;

pub type GLuint64 = u64;

pub use self::WebGL2RenderingContextBinding::{WebGL2RenderingContextConstants, Wrap, WebGL2RenderingContextMethods, GetProtoObject, DefineDOMInterface};
pub mod WebGL2RenderingContextBinding {
#![allow(non_camel_case_types,non_upper_case_globals,unused_imports,unused_variables,unused_assignments,unused_mut)]
use dom;
use dom::bindings;
use dom::bindings::callback::CallSetup;
use dom::bindings::callback::CallbackContainer;
use dom::bindings::callback::CallbackFunction;
use dom::bindings::callback::CallbackInterface;
use dom::bindings::callback::CallbackObject;
use dom::bindings::callback::ExceptionHandling;
use dom::bindings::callback::wrap_call_this_object;
use dom::bindings::codegen::Bindings::HTMLElementBinding::HTMLElementBinding;
use dom::bindings::codegen::Bindings::HTMLMediaElementBinding::HTMLMediaElementBinding;
use dom::bindings::codegen::Bindings::WebGLObjectBinding::WebGLObjectBinding;
use dom::bindings::codegen::Bindings::WebGLRenderingContextBinding::WebGLContextAttributes;
use dom::bindings::codegen::InterfaceObjectMap;
use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::codegen::UnionTypes;
use dom::bindings::constant::ConstantSpec;
use dom::bindings::constant::ConstantVal;
use dom::bindings::conversions::ConversionBehavior;
use dom::bindings::conversions::ConversionResult;
use dom::bindings::conversions::DOM_OBJECT_SLOT;
use dom::bindings::conversions::FromJSValConvertible;
use dom::bindings::conversions::IDLInterface;
use dom::bindings::conversions::StringificationBehavior;
use dom::bindings::conversions::ToJSValConvertible;
use dom::bindings::conversions::is_array_like;
use dom::bindings::conversions::jsid_to_string;
use dom::bindings::conversions::native_from_handlevalue;
use dom::bindings::conversions::native_from_object;
use dom::bindings::conversions::private_from_object;
use dom::bindings::conversions::root_from_handleobject;
use dom::bindings::conversions::root_from_handlevalue;
use dom::bindings::conversions::root_from_object;
use dom::bindings::error::Error;
use dom::bindings::error::Error::JSFailed;
use dom::bindings::error::ErrorResult;
use dom::bindings::error::Fallible;
use dom::bindings::error::throw_dom_exception;
use dom::bindings::guard::Condition;
use dom::bindings::guard::Guard;
use dom::bindings::htmlconstructor::html_constructor;
use dom::bindings::htmlconstructor::pop_current_element_queue;
use dom::bindings::htmlconstructor::push_new_element_queue;
use dom::bindings::inheritance::Castable;
use dom::bindings::interface::ConstructorClassHook;
use dom::bindings::interface::InterfaceConstructorBehavior;
use dom::bindings::interface::NonCallbackInterfaceObjectClass;
use dom::bindings::interface::create_callback_interface_object;
use dom::bindings::interface::create_global_object;
use dom::bindings::interface::create_interface_prototype_object;
use dom::bindings::interface::create_named_constructors;
use dom::bindings::interface::create_noncallback_interface_object;
use dom::bindings::interface::define_guarded_constants;
use dom::bindings::interface::define_guarded_methods;
use dom::bindings::interface::define_guarded_properties;
use dom::bindings::interface::is_exposed_in;
use dom::bindings::iterable::Iterable;
use dom::bindings::iterable::IteratorType;
use dom::bindings::mozmap::MozMap;
use dom::bindings::namespace::NamespaceObjectClass;
use dom::bindings::namespace::create_namespace_object;
use dom::bindings::num::Finite;
use dom::bindings::proxyhandler;
use dom::bindings::proxyhandler::ensure_expando_object;
use dom::bindings::proxyhandler::fill_property_descriptor;
use dom::bindings::proxyhandler::get_expando_object;
use dom::bindings::proxyhandler::get_property_descriptor;
use dom::bindings::reflector::DomObject;
use dom::bindings::reflector::MutDomObject;
use dom::bindings::root::Dom;
use dom::bindings::root::DomRoot;
use dom::bindings::root::OptionalHeapSetter;
use dom::bindings::root::RootedReference;
use dom::bindings::str::ByteString;
use dom::bindings::str::DOMString;
use dom::bindings::str::USVString;
use dom::bindings::trace::JSTraceable;
use dom::bindings::trace::RootedTraceable;
use dom::bindings::trace::RootedTraceableBox;
use dom::bindings::utils::AsVoidPtr;
use dom::bindings::utils::DOMClass;
use dom::bindings::utils::DOMJSClass;
use dom::bindings::utils::DOM_PROTO_UNFORGEABLE_HOLDER_SLOT;
use dom::bindings::utils::JSCLASS_DOM_GLOBAL;
use dom::bindings::utils::ProtoOrIfaceArray;
use dom::bindings::utils::enumerate_global;
use dom::bindings::utils::finalize_global;
use dom::bindings::utils::find_enum_value;
use dom::bindings::utils::generic_getter;
use dom::bindings::utils::generic_lenient_getter;
use dom::bindings::utils::generic_lenient_setter;
use dom::bindings::utils::generic_method;
use dom::bindings::utils::generic_setter;
use dom::bindings::utils::get_array_index_from_id;
use dom::bindings::utils::get_dictionary_property;
use dom::bindings::utils::get_property_on_prototype;
use dom::bindings::utils::get_proto_or_iface_array;
use dom::bindings::utils::has_property_on_prototype;
use dom::bindings::utils::is_platform_object;
use dom::bindings::utils::resolve_global;
use dom::bindings::utils::set_dictionary_property;
use dom::bindings::utils::trace_global;
use dom::bindings::weakref::DOM_WEAK_SLOT;
use dom::bindings::weakref::WeakBox;
use dom::bindings::weakref::WeakReferenceable;
use dom::globalscope::GlobalScope;
use dom::types::HTMLCanvasElement;
use dom::types::HTMLElement;
use dom::types::HTMLIFrameElement;
use dom::types::HTMLImageElement;
use dom::types::HTMLMediaElement;
use dom::types::HTMLVideoElement;
use dom::types::ImageData;
use dom::types::WebGL2RenderingContext;
use dom::types::WebGLActiveInfo;
use dom::types::WebGLBuffer;
use dom::types::WebGLFramebuffer;
use dom::types::WebGLObject;
use dom::types::WebGLProgram;
use dom::types::WebGLRenderbuffer;
use dom::types::WebGLShader;
use dom::types::WebGLShaderPrecisionFormat;
use dom::types::WebGLTexture;
use dom::types::WebGLUniformLocation;
use dom::windowproxy::WindowProxy;
use js;
use js::JSCLASS_GLOBAL_SLOT_COUNT;
use js::JSCLASS_IS_DOMJSCLASS;
use js::JSCLASS_IS_GLOBAL;
use js::JSCLASS_RESERVED_SLOTS_MASK;
use js::JS_CALLEE;
use js::error::throw_internal_error;
use js::error::throw_type_error;
use js::glue::AppendToAutoIdVector;
use js::glue::CallJitGetterOp;
use js::glue::CallJitMethodOp;
use js::glue::CallJitSetterOp;
use js::glue::CreateProxyHandler;
use js::glue::GetProxyPrivate;
use js::glue::ProxyTraps;
use js::glue::RUST_JSID_IS_INT;
use js::glue::RUST_JSID_IS_STRING;
use js::glue::RUST_SYMBOL_TO_JSID;
use js::glue::UnwrapObject;
use js::glue::int_to_jsid;
use js::jsapi::AutoIdVector;
use js::jsapi::CallArgs;
use js::jsapi::CurrentGlobalOrNull;
use js::jsapi::FreeOp;
use js::jsapi::GetWellKnownSymbol;
use js::jsapi::Handle as RawHandle;
use js::jsapi::HandleId as RawHandleId;
use js::jsapi::HandleObject as RawHandleObject;
use js::jsapi::HandleValue as RawHandleValue;
use js::jsapi::HandleValueArray;
use js::jsapi::Heap;
use js::jsapi::INTERNED_STRING_TO_JSID;
use js::jsapi::IsCallable;
use js::jsapi::JSAutoCompartment;
use js::jsapi::JSCLASS_RESERVED_SLOTS_SHIFT;
use js::jsapi::JSClass;
use js::jsapi::JSContext;
use js::jsapi::JSFreeOp;
use js::jsapi::JSFunctionSpec;
use js::jsapi::JSITER_HIDDEN;
use js::jsapi::JSITER_OWNONLY;
use js::jsapi::JSITER_SYMBOLS;
use js::jsapi::JSJitGetterCallArgs;
use js::jsapi::JSJitInfo;
use js::jsapi::JSJitInfo_AliasSet;
use js::jsapi::JSJitInfo_ArgType;
use js::jsapi::JSJitInfo_OpType;
use js::jsapi::JSJitMethodCallArgs;
use js::jsapi::JSJitSetterCallArgs;
use js::jsapi::JSNative;
use js::jsapi::JSNativeWrapper;
use js::jsapi::JSObject;
use js::jsapi::JSPROP_ENUMERATE;
use js::jsapi::JSPROP_PERMANENT;
use js::jsapi::JSPROP_READONLY;
use js::jsapi::JSPROP_SHARED;
use js::jsapi::JSPropertySpec;
use js::jsapi::JSString;
use js::jsapi::JSTracer;
use js::jsapi::JSType;
use js::jsapi::JSTypedMethodJitInfo;
use js::jsapi::JSValueType;
use js::jsapi::JS_AtomizeAndPinString;
use js::jsapi::JS_ForwardGetPropertyTo;
use js::jsapi::JS_GetErrorPrototype;
use js::jsapi::JS_GetGlobalForObject;
use js::jsapi::JS_GetIteratorPrototype;
use js::jsapi::JS_GetPropertyById;
use js::jsapi::JS_GetPropertyDescriptorById;
use js::jsapi::JS_GetReservedSlot;
use js::jsapi::JS_HasProperty;
use js::jsapi::JS_HasPropertyById;
use js::jsapi::JS_NewObject;
use js::jsapi::JS_SetReservedSlot;
use js::jsapi::MutableHandle as RawMutableHandle;
use js::jsapi::MutableHandleObject as RawMutableHandleObject;
use js::jsapi::MutableHandleValue as RawMutableHandleValue;
use js::jsapi::ObjectOpResult;
use js::jsapi::PropertyDescriptor;
use js::jsapi::Rooted;
use js::jsapi::RootedId;
use js::jsapi::RootedObject;
use js::jsapi::RootedString;
use js::jsapi::SymbolCode;
use js::jsapi::jsid;
use js::jsval::JSVal;
use js::jsval::NullValue;
use js::jsval::ObjectOrNullValue;
use js::jsval::ObjectValue;
use js::jsval::PrivateValue;
use js::jsval::UndefinedValue;
use js::panic::maybe_resume_unwind;
use js::panic::wrap_panic;
use js::rust::CustomAutoRooterGuard;
use js::rust::GCMethods;
use js::rust::Handle;
use js::rust::HandleId;
use js::rust::HandleObject;
use js::rust::HandleValue;
use js::rust::MutableHandle;
use js::rust::MutableHandleObject;
use js::rust::MutableHandleValue;
use js::rust::define_methods;
use js::rust::define_properties;
use js::rust::get_object_class;
use js::rust::wrappers::Call;
use js::rust::wrappers::GetPropertyKeys;
use js::rust::wrappers::JS_CallFunctionValue;
use js::rust::wrappers::JS_CopyPropertiesFrom;
use js::rust::wrappers::JS_DefineProperty;
use js::rust::wrappers::JS_DefinePropertyById2;
use js::rust::wrappers::JS_GetFunctionPrototype;
use js::rust::wrappers::JS_GetObjectPrototype;
use js::rust::wrappers::JS_GetProperty;
use js::rust::wrappers::JS_InitializePropertiesFromCompatibleNativeObject;
use js::rust::wrappers::JS_NewObjectWithGivenProto;
use js::rust::wrappers::JS_NewObjectWithoutMetadata;
use js::rust::wrappers::JS_ObjectIsDate;
use js::rust::wrappers::JS_SetImmutablePrototype;
use js::rust::wrappers::JS_SetProperty;
use js::rust::wrappers::JS_SetPrototype;
use js::rust::wrappers::JS_SplicePrototype;
use js::rust::wrappers::JS_WrapObject;
use js::rust::wrappers::JS_WrapValue;
use js::rust::wrappers::NewProxyObject;
use js::typedarray;
use libc;
use malloc_size_of::MallocSizeOfOps;
use mem::malloc_size_of_including_raw_self;
use servo_config::prefs::PREFS;
use std::borrow::ToOwned;
use std::cmp;
use std::default::Default;
use std::ffi::CString;
use std::mem;
use std::num;
use std::os;
use std::os::raw::c_void;
use std::panic;
use std::ptr;
use std::ptr::NonNull;
use std::rc;
use std::rc::Rc;
use std::str;
use typeholder::TypeHolderTrait;

unsafe extern fn bufferData<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 3);
        match argcount {
            3 => {
                let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                if args.get(1).get().is_null_or_undefined() {
                    let arg1: *mut JSObject = if args.get(1).get().is_object() {
                        args.get(1).get().to_object()
                    } else if args.get(1).get().is_null_or_undefined() {
                        ptr::null_mut()
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    };
                    let result: Result<(), Error<TH>> = this.BufferData(cx, arg0, arg1, arg2);
                    let result = match result {
                        Ok(result) => result,
                        Err(e) => {
                            throw_dom_exception(cx, &this.global(), e);
                            return false;
                        },
                    };

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                if args.get(1).get().is_object() {
                    loop {
                    let arg1: *mut JSObject = args.get(1).get().to_object();
                    let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    };
                    let result: Result<(), Error<TH>> = this.BufferData(cx, arg0, arg1, arg2);
                    let result = match result {
                        Ok(result) => result,
                        Err(e) => {
                            throw_dom_exception(cx, &this.global(), e);
                            return false;
                        },
                    };

                    (result).to_jsval(cx, args.rval());
                    return true;
                    }
                }
                if args.get(1).get().is_object() && is_array_like(cx, args.get(1)) {
                    let arg1: *mut JSObject = if args.get(1).get().is_object() {
                        args.get(1).get().to_object()
                    } else if args.get(1).get().is_null_or_undefined() {
                        ptr::null_mut()
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    };
                    let result: Result<(), Error<TH>> = this.BufferData(cx, arg0, arg1, arg2);
                    let result = match result {
                        Ok(result) => result,
                        Err(e) => {
                            throw_dom_exception(cx, &this.global(), e);
                            return false;
                        },
                    };

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                if args.get(1).get().is_object() && { rooted!(in(cx) let obj = args.get(1).get().to_object()); let mut is_date = false; assert!(JS_ObjectIsDate(cx, obj.handle(), &mut is_date)); is_date } {
                    let arg1: *mut JSObject = if args.get(1).get().is_object() {
                        args.get(1).get().to_object()
                    } else if args.get(1).get().is_null_or_undefined() {
                        ptr::null_mut()
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    };
                    let result: Result<(), Error<TH>> = this.BufferData(cx, arg0, arg1, arg2);
                    let result = match result {
                        Ok(result) => result,
                        Err(e) => {
                            throw_dom_exception(cx, &this.global(), e);
                            return false;
                        },
                    };

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                if args.get(1).get().is_object() && !is_platform_object(args.get(1).get().to_object()) {
                    let arg1: *mut JSObject = if args.get(1).get().is_object() {
                        args.get(1).get().to_object()
                    } else if args.get(1).get().is_null_or_undefined() {
                        ptr::null_mut()
                    } else {
                        throw_type_error(cx, "Value is not an object.");
                        return false;

                    };
                    let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                        Ok(ConversionResult::Success(v)) => v,
                        Ok(ConversionResult::Failure(error)) => {
                            throw_type_error(cx, &error);
                            return false;

                        }
                        _ => { return false;
                     }
                    };
                    let result: Result<(), Error<TH>> = this.BufferData(cx, arg0, arg1, arg2);
                    let result = match result {
                        Ok(result) => result,
                        Err(e) => {
                            throw_dom_exception(cx, &this.global(), e);
                            return false;
                        },
                    };

                    (result).to_jsval(cx, args.rval());
                    return true;
                }
                let arg1: i64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let result: Result<(), Error<TH>> = this.BufferData_(arg0, arg1, arg2);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, &this.global(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.bufferData\".");
                return false;
            }
        }
    }), false);
}


fn bufferData_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: bufferData::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn bufferSubData<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.bufferSubData\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i64 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: UnionTypes::ArrayBufferViewOrArrayBuffer = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.BufferSubData(arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn bufferSubData_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: bufferSubData::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn texImage2D<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 9);
        match argcount {
            6 => {
                let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg3: u32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg4: u32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg5: UnionTypes::ImageDataOrHTMLImageElementOrHTMLCanvasElementOrHTMLVideoElement<TH> = match FromJSValConvertible::from_jsval(cx, args.get(5), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let result: Result<(), Error<TH>> = this.TexImage2D_(arg0, arg1, arg2, arg3, arg4, arg5);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, &this.global(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            9 => {
                let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg4: i32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg5: i32 = match FromJSValConvertible::from_jsval(cx, args.get(5), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg6: u32 = match FromJSValConvertible::from_jsval(cx, args.get(6), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg7: u32 = match FromJSValConvertible::from_jsval(cx, args.get(7), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg8: Option<typedarray::ArrayBufferView> = if args.get(8).get().is_object() {
                    Some(match typedarray::ArrayBufferView::from(args.get(8).get().to_object()) {
                        Ok(val) => val,
                        Err(()) => {
                            throw_type_error(cx, "value is not a typed array.");
                            return false;

                        }
                    }
                    )
                } else if args.get(8).get().is_null_or_undefined() {
                    None
                } else {
                    throw_type_error(cx, "Value is not an object.");
                    return false;

                };
                auto_root!(in(cx) let arg8 = arg8);
                let result: Result<(), Error<TH>> = this.TexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, &this.global(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.texImage2D\".");
                return false;
            }
        }
    }), false);
}


fn texImage2D_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: texImage2D::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn texSubImage2D<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        let argcount = cmp::min(argc, 9);
        match argcount {
            7 => {
                let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg4: u32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg5: u32 = match FromJSValConvertible::from_jsval(cx, args.get(5), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg6: UnionTypes::ImageDataOrHTMLImageElementOrHTMLCanvasElementOrHTMLVideoElement<TH> = match FromJSValConvertible::from_jsval(cx, args.get(6), ()) {
                    Ok(ConversionResult::Success(value)) => value,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 },
                };
                let result: Result<(), Error<TH>> = this.TexSubImage2D_(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, &this.global(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            9 => {
                let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg4: i32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg5: i32 = match FromJSValConvertible::from_jsval(cx, args.get(5), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg6: u32 = match FromJSValConvertible::from_jsval(cx, args.get(6), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg7: u32 = match FromJSValConvertible::from_jsval(cx, args.get(7), ConversionBehavior::Default) {
                    Ok(ConversionResult::Success(v)) => v,
                    Ok(ConversionResult::Failure(error)) => {
                        throw_type_error(cx, &error);
                        return false;

                    }
                    _ => { return false;
                 }
                };
                let arg8: Option<typedarray::ArrayBufferView> = if args.get(8).get().is_object() {
                    Some(match typedarray::ArrayBufferView::from(args.get(8).get().to_object()) {
                        Ok(val) => val,
                        Err(()) => {
                            throw_type_error(cx, "value is not a typed array.");
                            return false;

                        }
                    }
                    )
                } else if args.get(8).get().is_null_or_undefined() {
                    None
                } else {
                    throw_type_error(cx, "Value is not an object.");
                    return false;

                };
                auto_root!(in(cx) let arg8 = arg8);
                let result: Result<(), Error<TH>> = this.TexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                let result = match result {
                    Ok(result) => result,
                    Err(e) => {
                        throw_dom_exception(cx, &this.global(), e);
                        return false;
                    },
                };

                (result).to_jsval(cx, args.rval());
                return true;
            }
            _ => {
                throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.texSubImage2D\".");
                return false;
            }
        }
    }), false);
}


fn texSubImage2D_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: texSubImage2D::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn readPixels<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 7 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.readPixels\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: u32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: u32 = match FromJSValConvertible::from_jsval(cx, args.get(5), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg6: Option<typedarray::ArrayBufferView> = if args.get(6).get().is_object() {
            Some(match typedarray::ArrayBufferView::from(args.get(6).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }
            )
        } else if args.get(6).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg6 = arg6);
        let result: () = this.ReadPixels(arg0, arg1, arg2, arg3, arg4, arg5, arg6);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn readPixels_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: readPixels::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_canvas<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: DomRoot<HTMLCanvasElement<TH>> = this.Canvas();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn canvas_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_canvas::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_OBJECT as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_drawingBufferWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.DrawingBufferWidth();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn drawingBufferWidth_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_drawingBufferWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn get_drawingBufferHeight<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: JSJitGetterCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let result: i32 = this.DrawingBufferHeight();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn drawingBufferHeight_getterinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: get_drawingBufferHeight::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Getter as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getContextAttributes<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<WebGLContextAttributes> = this.GetContextAttributes();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getContextAttributes_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getContextAttributes::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getSupportedExtensions<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<Vec<DOMString>> = this.GetSupportedExtensions();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getSupportedExtensions_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getSupportedExtensions::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getExtension<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getExtension\".");
            return false;
        }
        let arg0: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(0), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Option<NonNull<JSObject>> = this.GetExtension(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getExtension_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getExtension::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn activeTexture<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.activeTexture\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.ActiveTexture(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn activeTexture_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: activeTexture::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn attachShader<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.attachShader\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: DomRoot<WebGLShader<TH>> = if args.get(1).get().is_object() {
            match root_from_handlevalue(args.get(1)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLShader.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.AttachShader(&arg0, &arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn attachShader_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: attachShader::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn bindAttribLocation<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.bindAttribLocation\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(2), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.BindAttribLocation(&arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn bindAttribLocation_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: bindAttribLocation::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn bindBuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.bindBuffer\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: Option<DomRoot<WebGLBuffer<TH>>> = if args.get(1).get().is_object() {
            Some(match root_from_handlevalue(args.get(1)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLBuffer.");
                    return false;

                }
            }
            )
        } else if args.get(1).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.BindBuffer(arg0, arg1.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn bindBuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: bindBuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn bindFramebuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.bindFramebuffer\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: Option<DomRoot<WebGLFramebuffer<TH>>> = if args.get(1).get().is_object() {
            Some(match root_from_handlevalue(args.get(1)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLFramebuffer.");
                    return false;

                }
            }
            )
        } else if args.get(1).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.BindFramebuffer(arg0, arg1.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn bindFramebuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: bindFramebuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn bindRenderbuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.bindRenderbuffer\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: Option<DomRoot<WebGLRenderbuffer<TH>>> = if args.get(1).get().is_object() {
            Some(match root_from_handlevalue(args.get(1)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLRenderbuffer.");
                    return false;

                }
            }
            )
        } else if args.get(1).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.BindRenderbuffer(arg0, arg1.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn bindRenderbuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: bindRenderbuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn bindTexture<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.bindTexture\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: Option<DomRoot<WebGLTexture<TH>>> = if args.get(1).get().is_object() {
            Some(match root_from_handlevalue(args.get(1)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLTexture.");
                    return false;

                }
            }
            )
        } else if args.get(1).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.BindTexture(arg0, arg1.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn bindTexture_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: bindTexture::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn blendColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.blendColor\".");
            return false;
        }
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.BlendColor(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn blendColor_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: blendColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn blendEquation<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.blendEquation\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.BlendEquation(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn blendEquation_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: blendEquation::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn blendEquationSeparate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.blendEquationSeparate\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.BlendEquationSeparate(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn blendEquationSeparate_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: blendEquationSeparate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn blendFunc<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.blendFunc\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.BlendFunc(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn blendFunc_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: blendFunc::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn blendFuncSeparate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.blendFuncSeparate\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: u32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.BlendFuncSeparate(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn blendFuncSeparate_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: blendFuncSeparate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn checkFramebufferStatus<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.checkFramebufferStatus\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: u32 = this.CheckFramebufferStatus(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn checkFramebufferStatus_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: checkFramebufferStatus::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn clear<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.clear\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Clear(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clear_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: clear::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn clearColor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.clearColor\".");
            return false;
        }
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.ClearColor(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clearColor_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: clearColor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn clearDepth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.clearDepth\".");
            return false;
        }
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.ClearDepth(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clearDepth_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: clearDepth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn clearStencil<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.clearStencil\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.ClearStencil(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn clearStencil_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: clearStencil::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn colorMask<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.colorMask\".");
            return false;
        }
        let arg0: bool = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: bool = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: bool = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: bool = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.ColorMask(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn colorMask_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: colorMask::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn compileShader<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.compileShader\".");
            return false;
        }
        let arg0: DomRoot<WebGLShader<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLShader.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.CompileShader(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn compileShader_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: compileShader::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn compressedTexImage2D<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 7 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.compressedTexImage2D\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: i32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: i32 = match FromJSValConvertible::from_jsval(cx, args.get(5), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg6: typedarray::ArrayBufferView = if args.get(6).get().is_object() {
            match typedarray::ArrayBufferView::from(args.get(6).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg6 = arg6);
        let result: () = this.CompressedTexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn compressedTexImage2D_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: compressedTexImage2D::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn compressedTexSubImage2D<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 8 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.compressedTexSubImage2D\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: i32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: i32 = match FromJSValConvertible::from_jsval(cx, args.get(5), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg6: u32 = match FromJSValConvertible::from_jsval(cx, args.get(6), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg7: typedarray::ArrayBufferView = if args.get(7).get().is_object() {
            match typedarray::ArrayBufferView::from(args.get(7).get().to_object()) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value is not a typed array.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        auto_root!(in(cx) let arg7 = arg7);
        let result: () = this.CompressedTexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn compressedTexSubImage2D_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: compressedTexSubImage2D::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn copyTexImage2D<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 8 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.copyTexImage2D\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: i32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: i32 = match FromJSValConvertible::from_jsval(cx, args.get(5), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg6: i32 = match FromJSValConvertible::from_jsval(cx, args.get(6), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg7: i32 = match FromJSValConvertible::from_jsval(cx, args.get(7), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.CopyTexImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn copyTexImage2D_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: copyTexImage2D::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn copyTexSubImage2D<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 8 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.copyTexSubImage2D\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: i32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: i32 = match FromJSValConvertible::from_jsval(cx, args.get(5), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg6: i32 = match FromJSValConvertible::from_jsval(cx, args.get(6), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg7: i32 = match FromJSValConvertible::from_jsval(cx, args.get(7), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.CopyTexSubImage2D(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn copyTexSubImage2D_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: copyTexSubImage2D::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn createBuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<DomRoot<WebGLBuffer<TH>>> = this.CreateBuffer();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn createBuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: createBuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn createFramebuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<DomRoot<WebGLFramebuffer<TH>>> = this.CreateFramebuffer();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn createFramebuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: createFramebuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn createProgram<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<DomRoot<WebGLProgram<TH>>> = this.CreateProgram();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn createProgram_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: createProgram::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn createRenderbuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<DomRoot<WebGLRenderbuffer<TH>>> = this.CreateRenderbuffer();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn createRenderbuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: createRenderbuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn createShader<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.createShader\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: Option<DomRoot<WebGLShader<TH>>> = this.CreateShader(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn createShader_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: createShader::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn createTexture<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: Option<DomRoot<WebGLTexture<TH>>> = this.CreateTexture();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn createTexture_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: createTexture::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn cullFace<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.cullFace\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.CullFace(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn cullFace_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: cullFace::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn deleteBuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.deleteBuffer\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLBuffer<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLBuffer.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.DeleteBuffer(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn deleteBuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: deleteBuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn deleteFramebuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.deleteFramebuffer\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLFramebuffer<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLFramebuffer.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.DeleteFramebuffer(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn deleteFramebuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: deleteFramebuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn deleteProgram<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.deleteProgram\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLProgram<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.DeleteProgram(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn deleteProgram_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: deleteProgram::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn deleteRenderbuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.deleteRenderbuffer\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLRenderbuffer<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLRenderbuffer.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.DeleteRenderbuffer(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn deleteRenderbuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: deleteRenderbuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn deleteShader<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.deleteShader\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLShader<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLShader.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.DeleteShader(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn deleteShader_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: deleteShader::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn deleteTexture<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.deleteTexture\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLTexture<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLTexture.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.DeleteTexture(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn deleteTexture_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: deleteTexture::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn depthFunc<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.depthFunc\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.DepthFunc(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn depthFunc_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: depthFunc::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn depthMask<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.depthMask\".");
            return false;
        }
        let arg0: bool = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.DepthMask(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn depthMask_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: depthMask::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn depthRange<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.depthRange\".");
            return false;
        }
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.DepthRange(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn depthRange_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: depthRange::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn detachShader<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.detachShader\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: DomRoot<WebGLShader<TH>> = if args.get(1).get().is_object() {
            match root_from_handlevalue(args.get(1)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLShader.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.DetachShader(&arg0, &arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn detachShader_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: detachShader::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn disable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.disable\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Disable(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn disable_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: disable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn disableVertexAttribArray<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.disableVertexAttribArray\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.DisableVertexAttribArray(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn disableVertexAttribArray_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: disableVertexAttribArray::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn drawArrays<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.drawArrays\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.DrawArrays(arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn drawArrays_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: drawArrays::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn drawElements<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.drawElements\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i64 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.DrawElements(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn drawElements_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: drawElements::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn enable<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.enable\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Enable(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn enable_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: enable::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn enableVertexAttribArray<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.enableVertexAttribArray\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.EnableVertexAttribArray(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn enableVertexAttribArray_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: enableVertexAttribArray::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn finish<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Finish();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn finish_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: finish::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn flush<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: () = this.Flush();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn flush_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: flush::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn framebufferRenderbuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.framebufferRenderbuffer\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: Option<DomRoot<WebGLRenderbuffer<TH>>> = if args.get(3).get().is_object() {
            Some(match root_from_handlevalue(args.get(3)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLRenderbuffer.");
                    return false;

                }
            }
            )
        } else if args.get(3).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.FramebufferRenderbuffer(arg0, arg1, arg2, arg3.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn framebufferRenderbuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: framebufferRenderbuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn framebufferTexture2D<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 5 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.framebufferTexture2D\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: Option<DomRoot<WebGLTexture<TH>>> = if args.get(3).get().is_object() {
            Some(match root_from_handlevalue(args.get(3)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLTexture.");
                    return false;

                }
            }
            )
        } else if args.get(3).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg4: i32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.FramebufferTexture2D(arg0, arg1, arg2, arg3.r(), arg4);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn framebufferTexture2D_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: framebufferTexture2D::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn frontFace<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.frontFace\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.FrontFace(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn frontFace_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: frontFace::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn generateMipmap<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.generateMipmap\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.GenerateMipmap(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn generateMipmap_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: generateMipmap::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getActiveAttrib<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getActiveAttrib\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: Option<DomRoot<WebGLActiveInfo<TH>>> = this.GetActiveAttrib(&arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getActiveAttrib_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getActiveAttrib::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getActiveUniform<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getActiveUniform\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: Option<DomRoot<WebGLActiveInfo<TH>>> = this.GetActiveUniform(&arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getActiveUniform_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getActiveUniform::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getAttachedShaders<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getAttachedShaders\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: Option<Vec<DomRoot<WebGLShader<TH>>>> = this.GetAttachedShaders(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getAttachedShaders_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getAttachedShaders::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getAttribLocation<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getAttribLocation\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: i32 = this.GetAttribLocation(&arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getAttribLocation_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getAttribLocation::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_INT32 as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getBufferParameter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getBufferParameter\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: JSVal = this.GetBufferParameter(cx, arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getBufferParameter_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getBufferParameter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getParameter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getParameter\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: JSVal = this.GetParameter(cx, arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getParameter_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getParameter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getError<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;
        let result: u32 = this.GetError();

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getError_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getError::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        true,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getFramebufferAttachmentParameter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getFramebufferAttachmentParameter\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: JSVal = this.GetFramebufferAttachmentParameter(cx, arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getFramebufferAttachmentParameter_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getFramebufferAttachmentParameter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getProgramParameter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getProgramParameter\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: JSVal = this.GetProgramParameter(cx, &arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getProgramParameter_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getProgramParameter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getProgramInfoLog<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getProgramInfoLog\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: Option<DOMString> = this.GetProgramInfoLog(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getProgramInfoLog_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getProgramInfoLog::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getRenderbufferParameter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getRenderbufferParameter\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: JSVal = this.GetRenderbufferParameter(cx, arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getRenderbufferParameter_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getRenderbufferParameter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getShaderParameter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getShaderParameter\".");
            return false;
        }
        let arg0: DomRoot<WebGLShader<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLShader.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: JSVal = this.GetShaderParameter(cx, &arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getShaderParameter_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getShaderParameter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getShaderPrecisionFormat<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getShaderPrecisionFormat\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: Option<DomRoot<WebGLShaderPrecisionFormat<TH>>> = this.GetShaderPrecisionFormat(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getShaderPrecisionFormat_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getShaderPrecisionFormat::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getShaderInfoLog<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getShaderInfoLog\".");
            return false;
        }
        let arg0: DomRoot<WebGLShader<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLShader.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: Option<DOMString> = this.GetShaderInfoLog(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getShaderInfoLog_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getShaderInfoLog::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getShaderSource<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getShaderSource\".");
            return false;
        }
        let arg0: DomRoot<WebGLShader<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLShader.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: Option<DOMString> = this.GetShaderSource(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getShaderSource_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getShaderSource::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getTexParameter<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getTexParameter\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: JSVal = this.GetTexParameter(cx, arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getTexParameter_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getTexParameter::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getUniformLocation<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getUniformLocation\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: Option<DomRoot<WebGLUniformLocation<TH>>> = this.GetUniformLocation(&arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getUniformLocation_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getUniformLocation::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getVertexAttrib<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getVertexAttrib\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: JSVal = this.GetVertexAttrib(cx, arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getVertexAttrib_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getVertexAttrib::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNKNOWN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn getVertexAttribOffset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.getVertexAttribOffset\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: i64 = this.GetVertexAttribOffset(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn getVertexAttribOffset_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: getVertexAttribOffset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_DOUBLE as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn hint<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.hint\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Hint(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn hint_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: hint::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn isBuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.isBuffer\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLBuffer<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLBuffer.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: bool = this.IsBuffer(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn isBuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: isBuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn isEnabled<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.isEnabled\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: bool = this.IsEnabled(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn isEnabled_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: isEnabled::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn isFramebuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.isFramebuffer\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLFramebuffer<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLFramebuffer.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: bool = this.IsFramebuffer(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn isFramebuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: isFramebuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn isProgram<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.isProgram\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLProgram<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: bool = this.IsProgram(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn isProgram_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: isProgram::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn isRenderbuffer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.isRenderbuffer\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLRenderbuffer<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLRenderbuffer.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: bool = this.IsRenderbuffer(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn isRenderbuffer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: isRenderbuffer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn isShader<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.isShader\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLShader<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLShader.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: bool = this.IsShader(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn isShader_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: isShader::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn isTexture<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.isTexture\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLTexture<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLTexture.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: bool = this.IsTexture(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn isTexture_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: isTexture::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_BOOLEAN as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn lineWidth<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.lineWidth\".");
            return false;
        }
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.LineWidth(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn lineWidth_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: lineWidth::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn linkProgram<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.linkProgram\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLProgram<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.LinkProgram(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn linkProgram_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: linkProgram::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn pixelStorei<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.pixelStorei\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PixelStorei(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn pixelStorei_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: pixelStorei::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn polygonOffset<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.polygonOffset\".");
            return false;
        }
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.PolygonOffset(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn polygonOffset_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: polygonOffset::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn renderbufferStorage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.renderbufferStorage\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.RenderbufferStorage(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn renderbufferStorage_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: renderbufferStorage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn sampleCoverage<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.sampleCoverage\".");
            return false;
        }
        let arg0: f32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: bool = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.SampleCoverage(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn sampleCoverage_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: sampleCoverage::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn scissor<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.scissor\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Scissor(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn scissor_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: scissor::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn shaderSource<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.shaderSource\".");
            return false;
        }
        let arg0: DomRoot<WebGLShader<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLShader.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: DOMString = match FromJSValConvertible::from_jsval(cx, args.get(1), StringificationBehavior::Default) {
            Ok(ConversionResult::Success(strval)) => strval,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.ShaderSource(&arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn shaderSource_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: shaderSource::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn stencilFunc<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.stencilFunc\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.StencilFunc(arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn stencilFunc_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: stencilFunc::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn stencilFuncSeparate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.stencilFuncSeparate\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: u32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.StencilFuncSeparate(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn stencilFuncSeparate_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: stencilFuncSeparate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn stencilMask<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.stencilMask\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.StencilMask(arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn stencilMask_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: stencilMask::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn stencilMaskSeparate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.stencilMaskSeparate\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.StencilMaskSeparate(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn stencilMaskSeparate_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: stencilMaskSeparate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn stencilOp<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.stencilOp\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.StencilOp(arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn stencilOp_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: stencilOp::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn stencilOpSeparate<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.stencilOpSeparate\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: u32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.StencilOpSeparate(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn stencilOpSeparate_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: stencilOpSeparate::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn texImageDOM<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 8 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.texImageDOM\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: i32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: u32 = match FromJSValConvertible::from_jsval(cx, args.get(5), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg6: u32 = match FromJSValConvertible::from_jsval(cx, args.get(6), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg7: DomRoot<HTMLIFrameElement<TH>> = if args.get(7).get().is_object() {
            match root_from_handlevalue(args.get(7)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface HTMLIFrameElement.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: Result<(), Error<TH>> = this.TexImageDOM(arg0, arg1, arg2, arg3, arg4, arg5, arg6, &arg7);
        let result = match result {
            Ok(result) => result,
            Err(e) => {
                throw_dom_exception(cx, &this.global(), e);
                return false;
            },
        };

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn texImageDOM_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: texImageDOM::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn texParameterf<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.texParameterf\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.TexParameterf(arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn texParameterf_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: texParameterf::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn texParameteri<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.texParameteri\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: u32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.TexParameteri(arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn texParameteri_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: texParameteri::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform1f<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform1f\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Uniform1f(arg0.r(), arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform1f_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform1f::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform2f<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform2f\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Uniform2f(arg0.r(), arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform2f_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform2f::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform3f<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform3f\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Uniform3f(arg0.r(), arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform3f_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform3f::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform4f<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 5 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform4f\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: f32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Uniform4f(arg0.r(), arg1, arg2, arg3, arg4);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform4f_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform4f::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform1i<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform1i\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Uniform1i(arg0.r(), arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform1i_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform1i::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform2i<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform2i\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Uniform2i(arg0.r(), arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform2i_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform2i::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform3i<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform3i\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Uniform3i(arg0.r(), arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform3i_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform3i::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform4i<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 5 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform4i\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: i32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Uniform4i(arg0.r(), arg1, arg2, arg3, arg4);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform4i_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform4i::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform1fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform1fv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.Uniform1fv(arg0.r(), arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform1fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform1fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform2fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform2fv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.Uniform2fv(arg0.r(), arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform2fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform2fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform3fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform3fv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.Uniform3fv(arg0.r(), arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform3fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform3fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform4fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform4fv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.Uniform4fv(arg0.r(), arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform4fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform4fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform1iv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform1iv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: UnionTypes::Int32ArrayOrLongSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.Uniform1iv(arg0.r(), arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform1iv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform1iv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform2iv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform2iv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: UnionTypes::Int32ArrayOrLongSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.Uniform2iv(arg0.r(), arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform2iv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform2iv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform3iv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform3iv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: UnionTypes::Int32ArrayOrLongSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.Uniform3iv(arg0.r(), arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform3iv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform3iv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniform4iv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniform4iv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: UnionTypes::Int32ArrayOrLongSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.Uniform4iv(arg0.r(), arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniform4iv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniform4iv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniformMatrix2fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniformMatrix2fv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: bool = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.UniformMatrix2fv(arg0.r(), arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniformMatrix2fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniformMatrix2fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniformMatrix3fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniformMatrix3fv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: bool = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.UniformMatrix3fv(arg0.r(), arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniformMatrix3fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniformMatrix3fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn uniformMatrix4fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.uniformMatrix4fv\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLUniformLocation<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLUniformLocation.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let arg1: bool = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.UniformMatrix4fv(arg0.r(), arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn uniformMatrix4fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: uniformMatrix4fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn useProgram<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.useProgram\".");
            return false;
        }
        let arg0: Option<DomRoot<WebGLProgram<TH>>> = if args.get(0).get().is_object() {
            Some(match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }
            )
        } else if args.get(0).get().is_null_or_undefined() {
            None
        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.UseProgram(arg0.r());

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn useProgram_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: useProgram::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn validateProgram<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 1 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.validateProgram\".");
            return false;
        }
        let arg0: DomRoot<WebGLProgram<TH>> = if args.get(0).get().is_object() {
            match root_from_handlevalue(args.get(0)) {
                Ok(val) => val,
                Err(()) => {
                    throw_type_error(cx, "value does not implement interface WebGLProgram.");
                    return false;

                }
            }

        } else {
            throw_type_error(cx, "Value is not an object.");
            return false;

        };
        let result: () = this.ValidateProgram(&arg0);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn validateProgram_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: validateProgram::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn vertexAttrib1f<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.vertexAttrib1f\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.VertexAttrib1f(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn vertexAttrib1f_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: vertexAttrib1f::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn vertexAttrib2f<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 3 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.vertexAttrib2f\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.VertexAttrib2f(arg0, arg1, arg2);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn vertexAttrib2f_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: vertexAttrib2f::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn vertexAttrib3f<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.vertexAttrib3f\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.VertexAttrib3f(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn vertexAttrib3f_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: vertexAttrib3f::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn vertexAttrib4f<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 5 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.vertexAttrib4f\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: f32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: f32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: f32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: f32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.VertexAttrib4f(arg0, arg1, arg2, arg3, arg4);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn vertexAttrib4f_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: vertexAttrib4f::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn vertexAttrib1fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.vertexAttrib1fv\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.VertexAttrib1fv(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn vertexAttrib1fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: vertexAttrib1fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn vertexAttrib2fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.vertexAttrib2fv\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.VertexAttrib2fv(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn vertexAttrib2fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: vertexAttrib2fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn vertexAttrib3fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.vertexAttrib3fv\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.VertexAttrib3fv(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn vertexAttrib3fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: vertexAttrib3fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn vertexAttrib4fv<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 2 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.vertexAttrib4fv\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence = match FromJSValConvertible::from_jsval(cx, args.get(1), ()) {
            Ok(ConversionResult::Success(value)) => value,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         },
        };
        let result: () = this.VertexAttrib4fv(arg0, arg1);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn vertexAttrib4fv_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: vertexAttrib4fv::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn vertexAttribPointer<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 6 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.vertexAttribPointer\".");
            return false;
        }
        let arg0: u32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: u32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: bool = match FromJSValConvertible::from_jsval(cx, args.get(3), ()) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg4: i32 = match FromJSValConvertible::from_jsval(cx, args.get(4), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg5: i64 = match FromJSValConvertible::from_jsval(cx, args.get(5), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.VertexAttribPointer(arg0, arg1, arg2, arg3, arg4, arg5);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn vertexAttribPointer_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: vertexAttribPointer::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn viewport<TH: TypeHolderTrait>
(cx: *mut JSContext, _obj: HandleObject, this: *const WebGL2RenderingContext<TH>, args: *const JSJitMethodCallArgs) -> bool {
    return wrap_panic(panic::AssertUnwindSafe(|| {
        let this = &*this;
        let args = &*args;
        let argc = args._base.argc_;

        if argc < 4 {
            throw_type_error(cx, "Not enough arguments to \"WebGL2RenderingContext.viewport\".");
            return false;
        }
        let arg0: i32 = match FromJSValConvertible::from_jsval(cx, args.get(0), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg1: i32 = match FromJSValConvertible::from_jsval(cx, args.get(1), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg2: i32 = match FromJSValConvertible::from_jsval(cx, args.get(2), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let arg3: i32 = match FromJSValConvertible::from_jsval(cx, args.get(3), ConversionBehavior::Default) {
            Ok(ConversionResult::Success(v)) => v,
            Ok(ConversionResult::Failure(error)) => {
                throw_type_error(cx, &error);
                return false;

            }
            _ => { return false;
         }
        };
        let result: () = this.Viewport(arg0, arg1, arg2, arg3);

        (result).to_jsval(cx, args.rval());
        return true;
    }), false);
}


fn viewport_methodinfo<TH: TypeHolderTrait>() -> JSJitInfo { JSJitInfo {
    call: viewport::<TH> as *const os::raw::c_void,
    protoID: PrototypeList::ID::WebGL2RenderingContext as u16,
    depth: 0,
    _bitfield_1: new_jsjitinfo_bitfield_1!(
        JSJitInfo_OpType::Method as u8,
        JSJitInfo_AliasSet::AliasEverything as u8,
        JSValueType::JSVAL_TYPE_UNDEFINED as u8,
        false,
        false,
        false,
        false,
        false,
        false,
        0,
    ),
}}

unsafe extern fn _finalize<TH: TypeHolderTrait>
(_fop: *mut JSFreeOp, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<WebGL2RenderingContext<TH>>(obj).unwrap();
            if !this.is_null() {
                // The pointer can be null if the object is the unforgeable holder of that interface.
                let _ = Box::from_raw(this as *mut WebGL2RenderingContext<TH>);
            }
            debug!("WebGL2RenderingContext<TH> finalize: {:p}", this);
    }), ());
}

unsafe extern fn _trace<TH: TypeHolderTrait>
(trc: *mut JSTracer, obj: *mut JSObject) {
    return wrap_panic(panic::AssertUnwindSafe(|| {

        let this = native_from_object::<WebGL2RenderingContext<TH>>(obj).unwrap();
        if this.is_null() { return; } // GC during obj creation
        (*this).trace(trc);
    }), ());
}

pub mod WebGL2RenderingContextConstants {
    pub const READ_BUFFER: u32 = 3074;
    pub const UNPACK_ROW_LENGTH: u32 = 3314;
    pub const UNPACK_SKIP_ROWS: u32 = 3315;
    pub const UNPACK_SKIP_PIXELS: u32 = 3316;
    pub const PACK_ROW_LENGTH: u32 = 3330;
    pub const PACK_SKIP_ROWS: u32 = 3331;
    pub const PACK_SKIP_PIXELS: u32 = 3332;
    pub const COLOR: u32 = 6144;
    pub const DEPTH: u32 = 6145;
    pub const STENCIL: u32 = 6146;
    pub const RED: u32 = 6403;
    pub const RGB8: u32 = 32849;
    pub const RGBA8: u32 = 32856;
    pub const RGB10_A2: u32 = 32857;
    pub const TEXTURE_BINDING_3D: u32 = 32874;
    pub const UNPACK_SKIP_IMAGES: u32 = 32877;
    pub const UNPACK_IMAGE_HEIGHT: u32 = 32878;
    pub const TEXTURE_3D: u32 = 32879;
    pub const TEXTURE_WRAP_R: u32 = 32882;
    pub const MAX_3D_TEXTURE_SIZE: u32 = 32883;
    pub const UNSIGNED_INT_2_10_10_10_REV: u32 = 33640;
    pub const MAX_ELEMENTS_VERTICES: u32 = 33000;
    pub const MAX_ELEMENTS_INDICES: u32 = 33001;
    pub const TEXTURE_MIN_LOD: u32 = 33082;
    pub const TEXTURE_MAX_LOD: u32 = 33083;
    pub const TEXTURE_BASE_LEVEL: u32 = 33084;
    pub const TEXTURE_MAX_LEVEL: u32 = 33085;
    pub const MIN: u32 = 32775;
    pub const MAX: u32 = 32776;
    pub const DEPTH_COMPONENT24: u32 = 33190;
    pub const MAX_TEXTURE_LOD_BIAS: u32 = 34045;
    pub const TEXTURE_COMPARE_MODE: u32 = 34892;
    pub const TEXTURE_COMPARE_FUNC: u32 = 34893;
    pub const CURRENT_QUERY: u32 = 34917;
    pub const QUERY_RESULT: u32 = 34918;
    pub const QUERY_RESULT_AVAILABLE: u32 = 34919;
    pub const STREAM_READ: u32 = 35041;
    pub const STREAM_COPY: u32 = 35042;
    pub const STATIC_READ: u32 = 35045;
    pub const STATIC_COPY: u32 = 35046;
    pub const DYNAMIC_READ: u32 = 35049;
    pub const DYNAMIC_COPY: u32 = 35050;
    pub const MAX_DRAW_BUFFERS: u32 = 34852;
    pub const DRAW_BUFFER0: u32 = 34853;
    pub const DRAW_BUFFER1: u32 = 34854;
    pub const DRAW_BUFFER2: u32 = 34855;
    pub const DRAW_BUFFER3: u32 = 34856;
    pub const DRAW_BUFFER4: u32 = 34857;
    pub const DRAW_BUFFER5: u32 = 34858;
    pub const DRAW_BUFFER6: u32 = 34859;
    pub const DRAW_BUFFER7: u32 = 34860;
    pub const DRAW_BUFFER8: u32 = 34861;
    pub const DRAW_BUFFER9: u32 = 34862;
    pub const DRAW_BUFFER10: u32 = 34863;
    pub const DRAW_BUFFER11: u32 = 34864;
    pub const DRAW_BUFFER12: u32 = 34865;
    pub const DRAW_BUFFER13: u32 = 34866;
    pub const DRAW_BUFFER14: u32 = 34867;
    pub const DRAW_BUFFER15: u32 = 34868;
    pub const MAX_FRAGMENT_UNIFORM_COMPONENTS: u32 = 35657;
    pub const MAX_VERTEX_UNIFORM_COMPONENTS: u32 = 35658;
    pub const SAMPLER_3D: u32 = 35679;
    pub const SAMPLER_2D_SHADOW: u32 = 35682;
    pub const FRAGMENT_SHADER_DERIVATIVE_HINT: u32 = 35723;
    pub const PIXEL_PACK_BUFFER: u32 = 35051;
    pub const PIXEL_UNPACK_BUFFER: u32 = 35052;
    pub const PIXEL_PACK_BUFFER_BINDING: u32 = 35053;
    pub const PIXEL_UNPACK_BUFFER_BINDING: u32 = 35055;
    pub const FLOAT_MAT2x3: u32 = 35685;
    pub const FLOAT_MAT2x4: u32 = 35686;
    pub const FLOAT_MAT3x2: u32 = 35687;
    pub const FLOAT_MAT3x4: u32 = 35688;
    pub const FLOAT_MAT4x2: u32 = 35689;
    pub const FLOAT_MAT4x3: u32 = 35690;
    pub const SRGB: u32 = 35904;
    pub const SRGB8: u32 = 35905;
    pub const SRGB8_ALPHA8: u32 = 35907;
    pub const COMPARE_REF_TO_TEXTURE: u32 = 34894;
    pub const RGBA32F: u32 = 34836;
    pub const RGB32F: u32 = 34837;
    pub const RGBA16F: u32 = 34842;
    pub const RGB16F: u32 = 34843;
    pub const VERTEX_ATTRIB_ARRAY_INTEGER: u32 = 35069;
    pub const MAX_ARRAY_TEXTURE_LAYERS: u32 = 35071;
    pub const MIN_PROGRAM_TEXEL_OFFSET: u32 = 35076;
    pub const MAX_PROGRAM_TEXEL_OFFSET: u32 = 35077;
    pub const MAX_VARYING_COMPONENTS: u32 = 35659;
    pub const TEXTURE_2D_ARRAY: u32 = 35866;
    pub const TEXTURE_BINDING_2D_ARRAY: u32 = 35869;
    pub const R11F_G11F_B10F: u32 = 35898;
    pub const UNSIGNED_INT_10F_11F_11F_REV: u32 = 35899;
    pub const RGB9_E5: u32 = 35901;
    pub const UNSIGNED_INT_5_9_9_9_REV: u32 = 35902;
    pub const TRANSFORM_FEEDBACK_BUFFER_MODE: u32 = 35967;
    pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: u32 = 35968;
    pub const TRANSFORM_FEEDBACK_VARYINGS: u32 = 35971;
    pub const TRANSFORM_FEEDBACK_BUFFER_START: u32 = 35972;
    pub const TRANSFORM_FEEDBACK_BUFFER_SIZE: u32 = 35973;
    pub const TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: u32 = 35976;
    pub const RASTERIZER_DISCARD: u32 = 35977;
    pub const MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: u32 = 35978;
    pub const MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: u32 = 35979;
    pub const INTERLEAVED_ATTRIBS: u32 = 35980;
    pub const SEPARATE_ATTRIBS: u32 = 35981;
    pub const TRANSFORM_FEEDBACK_BUFFER: u32 = 35982;
    pub const TRANSFORM_FEEDBACK_BUFFER_BINDING: u32 = 35983;
    pub const RGBA32UI: u32 = 36208;
    pub const RGB32UI: u32 = 36209;
    pub const RGBA16UI: u32 = 36214;
    pub const RGB16UI: u32 = 36215;
    pub const RGBA8UI: u32 = 36220;
    pub const RGB8UI: u32 = 36221;
    pub const RGBA32I: u32 = 36226;
    pub const RGB32I: u32 = 36227;
    pub const RGBA16I: u32 = 36232;
    pub const RGB16I: u32 = 36233;
    pub const RGBA8I: u32 = 36238;
    pub const RGB8I: u32 = 36239;
    pub const RED_INTEGER: u32 = 36244;
    pub const RGB_INTEGER: u32 = 36248;
    pub const RGBA_INTEGER: u32 = 36249;
    pub const SAMPLER_2D_ARRAY: u32 = 36289;
    pub const SAMPLER_2D_ARRAY_SHADOW: u32 = 36292;
    pub const SAMPLER_CUBE_SHADOW: u32 = 36293;
    pub const UNSIGNED_INT_VEC2: u32 = 36294;
    pub const UNSIGNED_INT_VEC3: u32 = 36295;
    pub const UNSIGNED_INT_VEC4: u32 = 36296;
    pub const INT_SAMPLER_2D: u32 = 36298;
    pub const INT_SAMPLER_3D: u32 = 36299;
    pub const INT_SAMPLER_CUBE: u32 = 36300;
    pub const INT_SAMPLER_2D_ARRAY: u32 = 36303;
    pub const UNSIGNED_INT_SAMPLER_2D: u32 = 36306;
    pub const UNSIGNED_INT_SAMPLER_3D: u32 = 36307;
    pub const UNSIGNED_INT_SAMPLER_CUBE: u32 = 36308;
    pub const UNSIGNED_INT_SAMPLER_2D_ARRAY: u32 = 36311;
    pub const DEPTH_COMPONENT32F: u32 = 36012;
    pub const DEPTH32F_STENCIL8: u32 = 36013;
    pub const FLOAT_32_UNSIGNED_INT_24_8_REV: u32 = 36269;
    pub const FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: u32 = 33296;
    pub const FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: u32 = 33297;
    pub const FRAMEBUFFER_ATTACHMENT_RED_SIZE: u32 = 33298;
    pub const FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: u32 = 33299;
    pub const FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: u32 = 33300;
    pub const FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: u32 = 33301;
    pub const FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: u32 = 33302;
    pub const FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: u32 = 33303;
    pub const FRAMEBUFFER_DEFAULT: u32 = 33304;
    pub const UNSIGNED_INT_24_8: u32 = 34042;
    pub const DEPTH24_STENCIL8: u32 = 35056;
    pub const UNSIGNED_NORMALIZED: u32 = 35863;
    pub const DRAW_FRAMEBUFFER_BINDING: u32 = 36006;
    pub const READ_FRAMEBUFFER: u32 = 36008;
    pub const DRAW_FRAMEBUFFER: u32 = 36009;
    pub const READ_FRAMEBUFFER_BINDING: u32 = 36010;
    pub const RENDERBUFFER_SAMPLES: u32 = 36011;
    pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: u32 = 36052;
    pub const MAX_COLOR_ATTACHMENTS: u32 = 36063;
    pub const COLOR_ATTACHMENT1: u32 = 36065;
    pub const COLOR_ATTACHMENT2: u32 = 36066;
    pub const COLOR_ATTACHMENT3: u32 = 36067;
    pub const COLOR_ATTACHMENT4: u32 = 36068;
    pub const COLOR_ATTACHMENT5: u32 = 36069;
    pub const COLOR_ATTACHMENT6: u32 = 36070;
    pub const COLOR_ATTACHMENT7: u32 = 36071;
    pub const COLOR_ATTACHMENT8: u32 = 36072;
    pub const COLOR_ATTACHMENT9: u32 = 36073;
    pub const COLOR_ATTACHMENT10: u32 = 36074;
    pub const COLOR_ATTACHMENT11: u32 = 36075;
    pub const COLOR_ATTACHMENT12: u32 = 36076;
    pub const COLOR_ATTACHMENT13: u32 = 36077;
    pub const COLOR_ATTACHMENT14: u32 = 36078;
    pub const COLOR_ATTACHMENT15: u32 = 36079;
    pub const FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: u32 = 36182;
    pub const MAX_SAMPLES: u32 = 36183;
    pub const HALF_FLOAT: u32 = 5131;
    pub const RG: u32 = 33319;
    pub const RG_INTEGER: u32 = 33320;
    pub const R8: u32 = 33321;
    pub const RG8: u32 = 33323;
    pub const R16F: u32 = 33325;
    pub const R32F: u32 = 33326;
    pub const RG16F: u32 = 33327;
    pub const RG32F: u32 = 33328;
    pub const R8I: u32 = 33329;
    pub const R8UI: u32 = 33330;
    pub const R16I: u32 = 33331;
    pub const R16UI: u32 = 33332;
    pub const R32I: u32 = 33333;
    pub const R32UI: u32 = 33334;
    pub const RG8I: u32 = 33335;
    pub const RG8UI: u32 = 33336;
    pub const RG16I: u32 = 33337;
    pub const RG16UI: u32 = 33338;
    pub const RG32I: u32 = 33339;
    pub const RG32UI: u32 = 33340;
    pub const VERTEX_ARRAY_BINDING: u32 = 34229;
    pub const R8_SNORM: u32 = 36756;
    pub const RG8_SNORM: u32 = 36757;
    pub const RGB8_SNORM: u32 = 36758;
    pub const RGBA8_SNORM: u32 = 36759;
    pub const SIGNED_NORMALIZED: u32 = 36764;
    pub const COPY_READ_BUFFER: u32 = 36662;
    pub const COPY_WRITE_BUFFER: u32 = 36663;
    pub const COPY_READ_BUFFER_BINDING: u32 = 36662;
    pub const COPY_WRITE_BUFFER_BINDING: u32 = 36663;
    pub const UNIFORM_BUFFER: u32 = 35345;
    pub const UNIFORM_BUFFER_BINDING: u32 = 35368;
    pub const UNIFORM_BUFFER_START: u32 = 35369;
    pub const UNIFORM_BUFFER_SIZE: u32 = 35370;
    pub const MAX_VERTEX_UNIFORM_BLOCKS: u32 = 35371;
    pub const MAX_FRAGMENT_UNIFORM_BLOCKS: u32 = 35373;
    pub const MAX_COMBINED_UNIFORM_BLOCKS: u32 = 35374;
    pub const MAX_UNIFORM_BUFFER_BINDINGS: u32 = 35375;
    pub const MAX_UNIFORM_BLOCK_SIZE: u32 = 35376;
    pub const MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: u32 = 35377;
    pub const MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: u32 = 35379;
    pub const UNIFORM_BUFFER_OFFSET_ALIGNMENT: u32 = 35380;
    pub const ACTIVE_UNIFORM_BLOCKS: u32 = 35382;
    pub const UNIFORM_TYPE: u32 = 35383;
    pub const UNIFORM_SIZE: u32 = 35384;
    pub const UNIFORM_BLOCK_INDEX: u32 = 35386;
    pub const UNIFORM_OFFSET: u32 = 35387;
    pub const UNIFORM_ARRAY_STRIDE: u32 = 35388;
    pub const UNIFORM_MATRIX_STRIDE: u32 = 35389;
    pub const UNIFORM_IS_ROW_MAJOR: u32 = 35390;
    pub const UNIFORM_BLOCK_BINDING: u32 = 35391;
    pub const UNIFORM_BLOCK_DATA_SIZE: u32 = 35392;
    pub const UNIFORM_BLOCK_ACTIVE_UNIFORMS: u32 = 35394;
    pub const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: u32 = 35395;
    pub const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: u32 = 35396;
    pub const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: u32 = 35398;
    pub const INVALID_INDEX: u32 = 4294967295;
    pub const MAX_VERTEX_OUTPUT_COMPONENTS: u32 = 37154;
    pub const MAX_FRAGMENT_INPUT_COMPONENTS: u32 = 37157;
    pub const MAX_SERVER_WAIT_TIMEOUT: u32 = 37137;
    pub const OBJECT_TYPE: u32 = 37138;
    pub const SYNC_CONDITION: u32 = 37139;
    pub const SYNC_STATUS: u32 = 37140;
    pub const SYNC_FLAGS: u32 = 37141;
    pub const SYNC_FENCE: u32 = 37142;
    pub const SYNC_GPU_COMMANDS_COMPLETE: u32 = 37143;
    pub const UNSIGNALED: u32 = 37144;
    pub const SIGNALED: u32 = 37145;
    pub const ALREADY_SIGNALED: u32 = 37146;
    pub const TIMEOUT_EXPIRED: u32 = 37147;
    pub const CONDITION_SATISFIED: u32 = 37148;
    pub const WAIT_FAILED: u32 = 37149;
    pub const SYNC_FLUSH_COMMANDS_BIT: u32 = 1;
    pub const VERTEX_ATTRIB_ARRAY_DIVISOR: u32 = 35070;
    pub const ANY_SAMPLES_PASSED: u32 = 35887;
    pub const ANY_SAMPLES_PASSED_CONSERVATIVE: u32 = 36202;
    pub const SAMPLER_BINDING: u32 = 35097;
    pub const RGB10_A2UI: u32 = 36975;
    pub const INT_2_10_10_10_REV: u32 = 36255;
    pub const TRANSFORM_FEEDBACK: u32 = 36386;
    pub const TRANSFORM_FEEDBACK_PAUSED: u32 = 36387;
    pub const TRANSFORM_FEEDBACK_ACTIVE: u32 = 36388;
    pub const TRANSFORM_FEEDBACK_BINDING: u32 = 36389;
    pub const TEXTURE_IMMUTABLE_FORMAT: u32 = 37167;
    pub const MAX_ELEMENT_INDEX: u32 = 36203;
    pub const TEXTURE_IMMUTABLE_LEVELS: u32 = 33503;
    pub const TIMEOUT_IGNORED: i64 = -1;
    pub const MAX_CLIENT_WAIT_TIMEOUT_WEBGL: u32 = 37447;
    pub const DEPTH_BUFFER_BIT: u32 = 256;
    pub const STENCIL_BUFFER_BIT: u32 = 1024;
    pub const COLOR_BUFFER_BIT: u32 = 16384;
    pub const POINTS: u32 = 0;
    pub const LINES: u32 = 1;
    pub const LINE_LOOP: u32 = 2;
    pub const LINE_STRIP: u32 = 3;
    pub const TRIANGLES: u32 = 4;
    pub const TRIANGLE_STRIP: u32 = 5;
    pub const TRIANGLE_FAN: u32 = 6;
    pub const ZERO: u32 = 0;
    pub const ONE: u32 = 1;
    pub const SRC_COLOR: u32 = 768;
    pub const ONE_MINUS_SRC_COLOR: u32 = 769;
    pub const SRC_ALPHA: u32 = 770;
    pub const ONE_MINUS_SRC_ALPHA: u32 = 771;
    pub const DST_ALPHA: u32 = 772;
    pub const ONE_MINUS_DST_ALPHA: u32 = 773;
    pub const DST_COLOR: u32 = 774;
    pub const ONE_MINUS_DST_COLOR: u32 = 775;
    pub const SRC_ALPHA_SATURATE: u32 = 776;
    pub const FUNC_ADD: u32 = 32774;
    pub const BLEND_EQUATION: u32 = 32777;
    pub const BLEND_EQUATION_RGB: u32 = 32777;
    pub const BLEND_EQUATION_ALPHA: u32 = 34877;
    pub const FUNC_SUBTRACT: u32 = 32778;
    pub const FUNC_REVERSE_SUBTRACT: u32 = 32779;
    pub const BLEND_DST_RGB: u32 = 32968;
    pub const BLEND_SRC_RGB: u32 = 32969;
    pub const BLEND_DST_ALPHA: u32 = 32970;
    pub const BLEND_SRC_ALPHA: u32 = 32971;
    pub const CONSTANT_COLOR: u32 = 32769;
    pub const ONE_MINUS_CONSTANT_COLOR: u32 = 32770;
    pub const CONSTANT_ALPHA: u32 = 32771;
    pub const ONE_MINUS_CONSTANT_ALPHA: u32 = 32772;
    pub const BLEND_COLOR: u32 = 32773;
    pub const ARRAY_BUFFER: u32 = 34962;
    pub const ELEMENT_ARRAY_BUFFER: u32 = 34963;
    pub const ARRAY_BUFFER_BINDING: u32 = 34964;
    pub const ELEMENT_ARRAY_BUFFER_BINDING: u32 = 34965;
    pub const STREAM_DRAW: u32 = 35040;
    pub const STATIC_DRAW: u32 = 35044;
    pub const DYNAMIC_DRAW: u32 = 35048;
    pub const BUFFER_SIZE: u32 = 34660;
    pub const BUFFER_USAGE: u32 = 34661;
    pub const CURRENT_VERTEX_ATTRIB: u32 = 34342;
    pub const FRONT: u32 = 1028;
    pub const BACK: u32 = 1029;
    pub const FRONT_AND_BACK: u32 = 1032;
    pub const CULL_FACE: u32 = 2884;
    pub const BLEND: u32 = 3042;
    pub const DITHER: u32 = 3024;
    pub const STENCIL_TEST: u32 = 2960;
    pub const DEPTH_TEST: u32 = 2929;
    pub const SCISSOR_TEST: u32 = 3089;
    pub const POLYGON_OFFSET_FILL: u32 = 32823;
    pub const SAMPLE_ALPHA_TO_COVERAGE: u32 = 32926;
    pub const SAMPLE_COVERAGE: u32 = 32928;
    pub const NO_ERROR: u32 = 0;
    pub const INVALID_ENUM: u32 = 1280;
    pub const INVALID_VALUE: u32 = 1281;
    pub const INVALID_OPERATION: u32 = 1282;
    pub const OUT_OF_MEMORY: u32 = 1285;
    pub const CW: u32 = 2304;
    pub const CCW: u32 = 2305;
    pub const LINE_WIDTH: u32 = 2849;
    pub const ALIASED_POINT_SIZE_RANGE: u32 = 33901;
    pub const ALIASED_LINE_WIDTH_RANGE: u32 = 33902;
    pub const CULL_FACE_MODE: u32 = 2885;
    pub const FRONT_FACE: u32 = 2886;
    pub const DEPTH_RANGE: u32 = 2928;
    pub const DEPTH_WRITEMASK: u32 = 2930;
    pub const DEPTH_CLEAR_VALUE: u32 = 2931;
    pub const DEPTH_FUNC: u32 = 2932;
    pub const STENCIL_CLEAR_VALUE: u32 = 2961;
    pub const STENCIL_FUNC: u32 = 2962;
    pub const STENCIL_FAIL: u32 = 2964;
    pub const STENCIL_PASS_DEPTH_FAIL: u32 = 2965;
    pub const STENCIL_PASS_DEPTH_PASS: u32 = 2966;
    pub const STENCIL_REF: u32 = 2967;
    pub const STENCIL_VALUE_MASK: u32 = 2963;
    pub const STENCIL_WRITEMASK: u32 = 2968;
    pub const STENCIL_BACK_FUNC: u32 = 34816;
    pub const STENCIL_BACK_FAIL: u32 = 34817;
    pub const STENCIL_BACK_PASS_DEPTH_FAIL: u32 = 34818;
    pub const STENCIL_BACK_PASS_DEPTH_PASS: u32 = 34819;
    pub const STENCIL_BACK_REF: u32 = 36003;
    pub const STENCIL_BACK_VALUE_MASK: u32 = 36004;
    pub const STENCIL_BACK_WRITEMASK: u32 = 36005;
    pub const VIEWPORT: u32 = 2978;
    pub const SCISSOR_BOX: u32 = 3088;
    pub const COLOR_CLEAR_VALUE: u32 = 3106;
    pub const COLOR_WRITEMASK: u32 = 3107;
    pub const UNPACK_ALIGNMENT: u32 = 3317;
    pub const PACK_ALIGNMENT: u32 = 3333;
    pub const MAX_TEXTURE_SIZE: u32 = 3379;
    pub const MAX_VIEWPORT_DIMS: u32 = 3386;
    pub const SUBPIXEL_BITS: u32 = 3408;
    pub const RED_BITS: u32 = 3410;
    pub const GREEN_BITS: u32 = 3411;
    pub const BLUE_BITS: u32 = 3412;
    pub const ALPHA_BITS: u32 = 3413;
    pub const DEPTH_BITS: u32 = 3414;
    pub const STENCIL_BITS: u32 = 3415;
    pub const POLYGON_OFFSET_UNITS: u32 = 10752;
    pub const POLYGON_OFFSET_FACTOR: u32 = 32824;
    pub const TEXTURE_BINDING_2D: u32 = 32873;
    pub const SAMPLE_BUFFERS: u32 = 32936;
    pub const SAMPLES: u32 = 32937;
    pub const SAMPLE_COVERAGE_VALUE: u32 = 32938;
    pub const SAMPLE_COVERAGE_INVERT: u32 = 32939;
    pub const COMPRESSED_TEXTURE_FORMATS: u32 = 34467;
    pub const DONT_CARE: u32 = 4352;
    pub const FASTEST: u32 = 4353;
    pub const NICEST: u32 = 4354;
    pub const GENERATE_MIPMAP_HINT: u32 = 33170;
    pub const BYTE: u32 = 5120;
    pub const UNSIGNED_BYTE: u32 = 5121;
    pub const SHORT: u32 = 5122;
    pub const UNSIGNED_SHORT: u32 = 5123;
    pub const INT: u32 = 5124;
    pub const UNSIGNED_INT: u32 = 5125;
    pub const FLOAT: u32 = 5126;
    pub const DEPTH_COMPONENT: u32 = 6402;
    pub const ALPHA: u32 = 6406;
    pub const RGB: u32 = 6407;
    pub const RGBA: u32 = 6408;
    pub const LUMINANCE: u32 = 6409;
    pub const LUMINANCE_ALPHA: u32 = 6410;
    pub const UNSIGNED_SHORT_4_4_4_4: u32 = 32819;
    pub const UNSIGNED_SHORT_5_5_5_1: u32 = 32820;
    pub const UNSIGNED_SHORT_5_6_5: u32 = 33635;
    pub const FRAGMENT_SHADER: u32 = 35632;
    pub const VERTEX_SHADER: u32 = 35633;
    pub const MAX_VERTEX_ATTRIBS: u32 = 34921;
    pub const MAX_VERTEX_UNIFORM_VECTORS: u32 = 36347;
    pub const MAX_VARYING_VECTORS: u32 = 36348;
    pub const MAX_COMBINED_TEXTURE_IMAGE_UNITS: u32 = 35661;
    pub const MAX_VERTEX_TEXTURE_IMAGE_UNITS: u32 = 35660;
    pub const MAX_TEXTURE_IMAGE_UNITS: u32 = 34930;
    pub const MAX_FRAGMENT_UNIFORM_VECTORS: u32 = 36349;
    pub const SHADER_TYPE: u32 = 35663;
    pub const DELETE_STATUS: u32 = 35712;
    pub const LINK_STATUS: u32 = 35714;
    pub const VALIDATE_STATUS: u32 = 35715;
    pub const ATTACHED_SHADERS: u32 = 35717;
    pub const ACTIVE_UNIFORMS: u32 = 35718;
    pub const ACTIVE_ATTRIBUTES: u32 = 35721;
    pub const SHADING_LANGUAGE_VERSION: u32 = 35724;
    pub const CURRENT_PROGRAM: u32 = 35725;
    pub const NEVER: u32 = 512;
    pub const LESS: u32 = 513;
    pub const EQUAL: u32 = 514;
    pub const LEQUAL: u32 = 515;
    pub const GREATER: u32 = 516;
    pub const NOTEQUAL: u32 = 517;
    pub const GEQUAL: u32 = 518;
    pub const ALWAYS: u32 = 519;
    pub const KEEP: u32 = 7680;
    pub const REPLACE: u32 = 7681;
    pub const INCR: u32 = 7682;
    pub const DECR: u32 = 7683;
    pub const INVERT: u32 = 5386;
    pub const INCR_WRAP: u32 = 34055;
    pub const DECR_WRAP: u32 = 34056;
    pub const VENDOR: u32 = 7936;
    pub const RENDERER: u32 = 7937;
    pub const VERSION: u32 = 7938;
    pub const NEAREST: u32 = 9728;
    pub const LINEAR: u32 = 9729;
    pub const NEAREST_MIPMAP_NEAREST: u32 = 9984;
    pub const LINEAR_MIPMAP_NEAREST: u32 = 9985;
    pub const NEAREST_MIPMAP_LINEAR: u32 = 9986;
    pub const LINEAR_MIPMAP_LINEAR: u32 = 9987;
    pub const TEXTURE_MAG_FILTER: u32 = 10240;
    pub const TEXTURE_MIN_FILTER: u32 = 10241;
    pub const TEXTURE_WRAP_S: u32 = 10242;
    pub const TEXTURE_WRAP_T: u32 = 10243;
    pub const TEXTURE_2D: u32 = 3553;
    pub const TEXTURE: u32 = 5890;
    pub const TEXTURE_CUBE_MAP: u32 = 34067;
    pub const TEXTURE_BINDING_CUBE_MAP: u32 = 34068;
    pub const TEXTURE_CUBE_MAP_POSITIVE_X: u32 = 34069;
    pub const TEXTURE_CUBE_MAP_NEGATIVE_X: u32 = 34070;
    pub const TEXTURE_CUBE_MAP_POSITIVE_Y: u32 = 34071;
    pub const TEXTURE_CUBE_MAP_NEGATIVE_Y: u32 = 34072;
    pub const TEXTURE_CUBE_MAP_POSITIVE_Z: u32 = 34073;
    pub const TEXTURE_CUBE_MAP_NEGATIVE_Z: u32 = 34074;
    pub const MAX_CUBE_MAP_TEXTURE_SIZE: u32 = 34076;
    pub const TEXTURE0: u32 = 33984;
    pub const TEXTURE1: u32 = 33985;
    pub const TEXTURE2: u32 = 33986;
    pub const TEXTURE3: u32 = 33987;
    pub const TEXTURE4: u32 = 33988;
    pub const TEXTURE5: u32 = 33989;
    pub const TEXTURE6: u32 = 33990;
    pub const TEXTURE7: u32 = 33991;
    pub const TEXTURE8: u32 = 33992;
    pub const TEXTURE9: u32 = 33993;
    pub const TEXTURE10: u32 = 33994;
    pub const TEXTURE11: u32 = 33995;
    pub const TEXTURE12: u32 = 33996;
    pub const TEXTURE13: u32 = 33997;
    pub const TEXTURE14: u32 = 33998;
    pub const TEXTURE15: u32 = 33999;
    pub const TEXTURE16: u32 = 34000;
    pub const TEXTURE17: u32 = 34001;
    pub const TEXTURE18: u32 = 34002;
    pub const TEXTURE19: u32 = 34003;
    pub const TEXTURE20: u32 = 34004;
    pub const TEXTURE21: u32 = 34005;
    pub const TEXTURE22: u32 = 34006;
    pub const TEXTURE23: u32 = 34007;
    pub const TEXTURE24: u32 = 34008;
    pub const TEXTURE25: u32 = 34009;
    pub const TEXTURE26: u32 = 34010;
    pub const TEXTURE27: u32 = 34011;
    pub const TEXTURE28: u32 = 34012;
    pub const TEXTURE29: u32 = 34013;
    pub const TEXTURE30: u32 = 34014;
    pub const TEXTURE31: u32 = 34015;
    pub const ACTIVE_TEXTURE: u32 = 34016;
    pub const REPEAT: u32 = 10497;
    pub const CLAMP_TO_EDGE: u32 = 33071;
    pub const MIRRORED_REPEAT: u32 = 33648;
    pub const FLOAT_VEC2: u32 = 35664;
    pub const FLOAT_VEC3: u32 = 35665;
    pub const FLOAT_VEC4: u32 = 35666;
    pub const INT_VEC2: u32 = 35667;
    pub const INT_VEC3: u32 = 35668;
    pub const INT_VEC4: u32 = 35669;
    pub const BOOL: u32 = 35670;
    pub const BOOL_VEC2: u32 = 35671;
    pub const BOOL_VEC3: u32 = 35672;
    pub const BOOL_VEC4: u32 = 35673;
    pub const FLOAT_MAT2: u32 = 35674;
    pub const FLOAT_MAT3: u32 = 35675;
    pub const FLOAT_MAT4: u32 = 35676;
    pub const SAMPLER_2D: u32 = 35678;
    pub const SAMPLER_CUBE: u32 = 35680;
    pub const VERTEX_ATTRIB_ARRAY_ENABLED: u32 = 34338;
    pub const VERTEX_ATTRIB_ARRAY_SIZE: u32 = 34339;
    pub const VERTEX_ATTRIB_ARRAY_STRIDE: u32 = 34340;
    pub const VERTEX_ATTRIB_ARRAY_TYPE: u32 = 34341;
    pub const VERTEX_ATTRIB_ARRAY_NORMALIZED: u32 = 34922;
    pub const VERTEX_ATTRIB_ARRAY_POINTER: u32 = 34373;
    pub const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: u32 = 34975;
    pub const IMPLEMENTATION_COLOR_READ_TYPE: u32 = 35738;
    pub const IMPLEMENTATION_COLOR_READ_FORMAT: u32 = 35739;
    pub const COMPILE_STATUS: u32 = 35713;
    pub const LOW_FLOAT: u32 = 36336;
    pub const MEDIUM_FLOAT: u32 = 36337;
    pub const HIGH_FLOAT: u32 = 36338;
    pub const LOW_INT: u32 = 36339;
    pub const MEDIUM_INT: u32 = 36340;
    pub const HIGH_INT: u32 = 36341;
    pub const FRAMEBUFFER: u32 = 36160;
    pub const RENDERBUFFER: u32 = 36161;
    pub const RGBA4: u32 = 32854;
    pub const RGB5_A1: u32 = 32855;
    pub const RGB565: u32 = 36194;
    pub const DEPTH_COMPONENT16: u32 = 33189;
    pub const STENCIL_INDEX: u32 = 6401;
    pub const STENCIL_INDEX8: u32 = 36168;
    pub const DEPTH_STENCIL: u32 = 34041;
    pub const RENDERBUFFER_WIDTH: u32 = 36162;
    pub const RENDERBUFFER_HEIGHT: u32 = 36163;
    pub const RENDERBUFFER_INTERNAL_FORMAT: u32 = 36164;
    pub const RENDERBUFFER_RED_SIZE: u32 = 36176;
    pub const RENDERBUFFER_GREEN_SIZE: u32 = 36177;
    pub const RENDERBUFFER_BLUE_SIZE: u32 = 36178;
    pub const RENDERBUFFER_ALPHA_SIZE: u32 = 36179;
    pub const RENDERBUFFER_DEPTH_SIZE: u32 = 36180;
    pub const RENDERBUFFER_STENCIL_SIZE: u32 = 36181;
    pub const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: u32 = 36048;
    pub const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: u32 = 36049;
    pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: u32 = 36050;
    pub const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: u32 = 36051;
    pub const COLOR_ATTACHMENT0: u32 = 36064;
    pub const DEPTH_ATTACHMENT: u32 = 36096;
    pub const STENCIL_ATTACHMENT: u32 = 36128;
    pub const DEPTH_STENCIL_ATTACHMENT: u32 = 33306;
    pub const NONE: u32 = 0;
    pub const FRAMEBUFFER_COMPLETE: u32 = 36053;
    pub const FRAMEBUFFER_INCOMPLETE_ATTACHMENT: u32 = 36054;
    pub const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: u32 = 36055;
    pub const FRAMEBUFFER_INCOMPLETE_DIMENSIONS: u32 = 36057;
    pub const FRAMEBUFFER_UNSUPPORTED: u32 = 36061;
    pub const FRAMEBUFFER_BINDING: u32 = 36006;
    pub const RENDERBUFFER_BINDING: u32 = 36007;
    pub const MAX_RENDERBUFFER_SIZE: u32 = 34024;
    pub const INVALID_FRAMEBUFFER_OPERATION: u32 = 1286;
    pub const UNPACK_FLIP_Y_WEBGL: u32 = 37440;
    pub const UNPACK_PREMULTIPLY_ALPHA_WEBGL: u32 = 37441;
    pub const CONTEXT_LOST_WEBGL: u32 = 37442;
    pub const UNPACK_COLORSPACE_CONVERSION_WEBGL: u32 = 37443;
    pub const BROWSER_DEFAULT_WEBGL: u32 = 37444;
} // mod WebGL2RenderingContextConstants
fn CLASS_OPS<TH: TypeHolderTrait>() -> js::jsapi::JSClassOps { js::jsapi::JSClassOps {
    addProperty: None,
    delProperty: None,
    getProperty: None,
    setProperty: None,
    enumerate: None,
    resolve: None,
    mayResolve: None,
    finalize: Some(_finalize::<TH>),
    call: None,
    hasInstance: None,
    construct: None,
    trace: Some(_trace::<TH>),
}}

fn Class<TH: TypeHolderTrait>() -> DOMJSClass { DOMJSClass {
    base: js::jsapi::JSClass {
        name: b"WebGL2RenderingContext\0" as *const u8 as *const libc::c_char,
        flags: JSCLASS_IS_DOMJSCLASS | 0 |
               (((1) & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT)
               /* JSCLASS_HAS_RESERVED_SLOTS(1) */,
        cOps: &CLASS_OPS::<TH>(),
        reserved: [0 as *mut _; 3],
    },
    dom_class: DOMClass {
    interface_chain: [ PrototypeList::ID::WebGL2RenderingContext, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last, PrototypeList::ID::Last ],
    type_id: ::dom::bindings::codegen::InheritTypes::TopTypeId { alone: () },
    global: InterfaceObjectMap::Globals::EMPTY,
    malloc_size_of: malloc_size_of_including_raw_self::<WebGL2RenderingContext<TH>> as unsafe fn(&mut _, _) -> _,
}
}}

#[inline]
fn malloc_size<TH: TypeHolderTrait>(ops: &mut MallocSizeOfOps, obj: *const c_void) -> usize {
    malloc_size_of_including_raw_self::<WebGL2RenderingContext<TH>>(ops, obj)
}

pub unsafe fn Wrap<TH: TypeHolderTrait>
(cx: *mut JSContext, scope: &GlobalScope<TH>, object: Box<WebGL2RenderingContext<TH>>) -> DomRoot<WebGL2RenderingContext<TH>> {
    let scope = scope.reflector().get_jsobject();
    assert!(!scope.get().is_null());
    assert!(((*get_object_class(scope.get())).flags & JSCLASS_IS_GLOBAL) != 0);

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    let _ac = JSAutoCompartment::new(cx, scope.get());
    GetProtoObject(cx, scope, proto.handle_mut());
    assert!(!proto.is_null());

    let raw = Box::into_raw(object);
    let _rt = RootedTraceable::new(&*raw);
    rooted!(in(cx) let obj = JS_NewObjectWithGivenProto(
        cx, &Class::<TH>().base as *const JSClass, proto.handle()));
    assert!(!obj.is_null());

    JS_SetReservedSlot(obj.get(), DOM_OBJECT_SLOT,
                       PrivateValue(raw as *const libc::c_void));


    (*raw).init_reflector(obj.get());

    DomRoot::from_ref(&*raw)
}

impl<TH: TypeHolderTrait> IDLInterface for WebGL2RenderingContext<TH> {
    #[inline]
    fn derives(class: &'static DOMClass) -> bool {
        class as *const _ == &Class::<TH>().dom_class as *const _
    }
}

impl<TH: TypeHolderTrait> PartialEq for WebGL2RenderingContext<TH> {
    fn eq(&self, other: &WebGL2RenderingContext<TH>) -> bool {
        self as *const WebGL2RenderingContext<TH> == &*other
    }
}

pub trait WebGL2RenderingContextMethods<TH: TypeHolderTrait> {
    unsafe fn BufferData(&self, cx: *mut JSContext, target: u32, data: *mut JSObject, usage: u32) -> Fallible<(), TH>;
    fn BufferData_(&self, target: u32, size: i64, usage: u32) -> Fallible<(), TH>;
    fn BufferSubData(&self, target: u32, dstByteOffset: i64, srcData: UnionTypes::ArrayBufferViewOrArrayBuffer) -> ();
    fn TexImage2D(&self, target: u32, level: i32, internalformat: u32, width: i32, height: i32, border: i32, format: u32, type_: u32, pixels: CustomAutoRooterGuard<Option<typedarray::ArrayBufferView>>) -> Fallible<(), TH>;
    fn TexImage2D_(&self, target: u32, level: i32, internalformat: u32, format: u32, type_: u32, source: UnionTypes::ImageDataOrHTMLImageElementOrHTMLCanvasElementOrHTMLVideoElement<TH>) -> Fallible<(), TH>;
    fn TexSubImage2D(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, type_: u32, pixels: CustomAutoRooterGuard<Option<typedarray::ArrayBufferView>>) -> Fallible<(), TH>;
    fn TexSubImage2D_(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, format: u32, type_: u32, source: UnionTypes::ImageDataOrHTMLImageElementOrHTMLCanvasElementOrHTMLVideoElement<TH>) -> Fallible<(), TH>;
    fn ReadPixels(&self, x: i32, y: i32, width: i32, height: i32, format: u32, type_: u32, dstData: CustomAutoRooterGuard<Option<typedarray::ArrayBufferView>>) -> ();
    fn Canvas(&self) -> DomRoot<HTMLCanvasElement<TH>>;
    fn DrawingBufferWidth(&self) -> i32;
    fn DrawingBufferHeight(&self) -> i32;
    fn GetContextAttributes(&self) -> Option<WebGLContextAttributes>;
    fn GetSupportedExtensions(&self) -> Option<Vec<DOMString>>;
    unsafe fn GetExtension(&self, cx: *mut JSContext, name: DOMString) -> Option<NonNull<JSObject>>;
    fn ActiveTexture(&self, texture: u32) -> ();
    fn AttachShader(&self, program: &WebGLProgram<TH>, shader: &WebGLShader<TH>) -> ();
    fn BindAttribLocation(&self, program: &WebGLProgram<TH>, index: u32, name: DOMString) -> ();
    fn BindBuffer(&self, target: u32, buffer: Option<&WebGLBuffer<TH>>) -> ();
    fn BindFramebuffer(&self, target: u32, framebuffer: Option<&WebGLFramebuffer<TH>>) -> ();
    fn BindRenderbuffer(&self, target: u32, renderbuffer: Option<&WebGLRenderbuffer<TH>>) -> ();
    fn BindTexture(&self, target: u32, texture: Option<&WebGLTexture<TH>>) -> ();
    fn BlendColor(&self, red: f32, green: f32, blue: f32, alpha: f32) -> ();
    fn BlendEquation(&self, mode: u32) -> ();
    fn BlendEquationSeparate(&self, modeRGB: u32, modeAlpha: u32) -> ();
    fn BlendFunc(&self, sfactor: u32, dfactor: u32) -> ();
    fn BlendFuncSeparate(&self, srcRGB: u32, dstRGB: u32, srcAlpha: u32, dstAlpha: u32) -> ();
    fn CheckFramebufferStatus(&self, target: u32) -> u32;
    fn Clear(&self, mask: u32) -> ();
    fn ClearColor(&self, red: f32, green: f32, blue: f32, alpha: f32) -> ();
    fn ClearDepth(&self, depth: f32) -> ();
    fn ClearStencil(&self, s: i32) -> ();
    fn ColorMask(&self, red: bool, green: bool, blue: bool, alpha: bool) -> ();
    fn CompileShader(&self, shader: &WebGLShader<TH>) -> ();
    fn CompressedTexImage2D(&self, target: u32, level: i32, internalformat: u32, width: i32, height: i32, border: i32, data: CustomAutoRooterGuard<typedarray::ArrayBufferView>) -> ();
    fn CompressedTexSubImage2D(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, width: i32, height: i32, format: u32, data: CustomAutoRooterGuard<typedarray::ArrayBufferView>) -> ();
    fn CopyTexImage2D(&self, target: u32, level: i32, internalformat: u32, x: i32, y: i32, width: i32, height: i32, border: i32) -> ();
    fn CopyTexSubImage2D(&self, target: u32, level: i32, xoffset: i32, yoffset: i32, x: i32, y: i32, width: i32, height: i32) -> ();
    fn CreateBuffer(&self) -> Option<DomRoot<WebGLBuffer<TH>>>;
    fn CreateFramebuffer(&self) -> Option<DomRoot<WebGLFramebuffer<TH>>>;
    fn CreateProgram(&self) -> Option<DomRoot<WebGLProgram<TH>>>;
    fn CreateRenderbuffer(&self) -> Option<DomRoot<WebGLRenderbuffer<TH>>>;
    fn CreateShader(&self, type_: u32) -> Option<DomRoot<WebGLShader<TH>>>;
    fn CreateTexture(&self) -> Option<DomRoot<WebGLTexture<TH>>>;
    fn CullFace(&self, mode: u32) -> ();
    fn DeleteBuffer(&self, buffer: Option<&WebGLBuffer<TH>>) -> ();
    fn DeleteFramebuffer(&self, framebuffer: Option<&WebGLFramebuffer<TH>>) -> ();
    fn DeleteProgram(&self, program: Option<&WebGLProgram<TH>>) -> ();
    fn DeleteRenderbuffer(&self, renderbuffer: Option<&WebGLRenderbuffer<TH>>) -> ();
    fn DeleteShader(&self, shader: Option<&WebGLShader<TH>>) -> ();
    fn DeleteTexture(&self, texture: Option<&WebGLTexture<TH>>) -> ();
    fn DepthFunc(&self, func: u32) -> ();
    fn DepthMask(&self, flag: bool) -> ();
    fn DepthRange(&self, zNear: f32, zFar: f32) -> ();
    fn DetachShader(&self, program: &WebGLProgram<TH>, shader: &WebGLShader<TH>) -> ();
    fn Disable(&self, cap: u32) -> ();
    fn DisableVertexAttribArray(&self, index: u32) -> ();
    fn DrawArrays(&self, mode: u32, first: i32, count: i32) -> ();
    fn DrawElements(&self, mode: u32, count: i32, type_: u32, offset: i64) -> ();
    fn Enable(&self, cap: u32) -> ();
    fn EnableVertexAttribArray(&self, index: u32) -> ();
    fn Finish(&self) -> ();
    fn Flush(&self) -> ();
    fn FramebufferRenderbuffer(&self, target: u32, attachment: u32, renderbuffertarget: u32, renderbuffer: Option<&WebGLRenderbuffer<TH>>) -> ();
    fn FramebufferTexture2D(&self, target: u32, attachment: u32, textarget: u32, texture: Option<&WebGLTexture<TH>>, level: i32) -> ();
    fn FrontFace(&self, mode: u32) -> ();
    fn GenerateMipmap(&self, target: u32) -> ();
    fn GetActiveAttrib(&self, program: &WebGLProgram<TH>, index: u32) -> Option<DomRoot<WebGLActiveInfo<TH>>>;
    fn GetActiveUniform(&self, program: &WebGLProgram<TH>, index: u32) -> Option<DomRoot<WebGLActiveInfo<TH>>>;
    fn GetAttachedShaders(&self, program: &WebGLProgram<TH>) -> Option<Vec<DomRoot<WebGLShader<TH>>>>;
    fn GetAttribLocation(&self, program: &WebGLProgram<TH>, name: DOMString) -> i32;
    unsafe fn GetBufferParameter(&self, cx: *mut JSContext, target: u32, pname: u32) -> JSVal;
    unsafe fn GetParameter(&self, cx: *mut JSContext, pname: u32) -> JSVal;
    fn GetError(&self) -> u32;
    unsafe fn GetFramebufferAttachmentParameter(&self, cx: *mut JSContext, target: u32, attachment: u32, pname: u32) -> JSVal;
    unsafe fn GetProgramParameter(&self, cx: *mut JSContext, program: &WebGLProgram<TH>, pname: u32) -> JSVal;
    fn GetProgramInfoLog(&self, program: &WebGLProgram<TH>) -> Option<DOMString>;
    unsafe fn GetRenderbufferParameter(&self, cx: *mut JSContext, target: u32, pname: u32) -> JSVal;
    unsafe fn GetShaderParameter(&self, cx: *mut JSContext, shader: &WebGLShader<TH>, pname: u32) -> JSVal;
    fn GetShaderPrecisionFormat(&self, shadertype: u32, precisiontype: u32) -> Option<DomRoot<WebGLShaderPrecisionFormat<TH>>>;
    fn GetShaderInfoLog(&self, shader: &WebGLShader<TH>) -> Option<DOMString>;
    fn GetShaderSource(&self, shader: &WebGLShader<TH>) -> Option<DOMString>;
    unsafe fn GetTexParameter(&self, cx: *mut JSContext, target: u32, pname: u32) -> JSVal;
    fn GetUniformLocation(&self, program: &WebGLProgram<TH>, name: DOMString) -> Option<DomRoot<WebGLUniformLocation<TH>>>;
    unsafe fn GetVertexAttrib(&self, cx: *mut JSContext, index: u32, pname: u32) -> JSVal;
    fn GetVertexAttribOffset(&self, index: u32, pname: u32) -> i64;
    fn Hint(&self, target: u32, mode: u32) -> ();
    fn IsBuffer(&self, buffer: Option<&WebGLBuffer<TH>>) -> bool;
    fn IsEnabled(&self, cap: u32) -> bool;
    fn IsFramebuffer(&self, framebuffer: Option<&WebGLFramebuffer<TH>>) -> bool;
    fn IsProgram(&self, program: Option<&WebGLProgram<TH>>) -> bool;
    fn IsRenderbuffer(&self, renderbuffer: Option<&WebGLRenderbuffer<TH>>) -> bool;
    fn IsShader(&self, shader: Option<&WebGLShader<TH>>) -> bool;
    fn IsTexture(&self, texture: Option<&WebGLTexture<TH>>) -> bool;
    fn LineWidth(&self, width: f32) -> ();
    fn LinkProgram(&self, program: Option<&WebGLProgram<TH>>) -> ();
    fn PixelStorei(&self, pname: u32, param: i32) -> ();
    fn PolygonOffset(&self, factor: f32, units: f32) -> ();
    fn RenderbufferStorage(&self, target: u32, internalformat: u32, width: i32, height: i32) -> ();
    fn SampleCoverage(&self, value: f32, invert: bool) -> ();
    fn Scissor(&self, x: i32, y: i32, width: i32, height: i32) -> ();
    fn ShaderSource(&self, shader: &WebGLShader<TH>, source: DOMString) -> ();
    fn StencilFunc(&self, func: u32, ref_: i32, mask: u32) -> ();
    fn StencilFuncSeparate(&self, face: u32, func: u32, ref_: i32, mask: u32) -> ();
    fn StencilMask(&self, mask: u32) -> ();
    fn StencilMaskSeparate(&self, face: u32, mask: u32) -> ();
    fn StencilOp(&self, fail: u32, zfail: u32, zpass: u32) -> ();
    fn StencilOpSeparate(&self, face: u32, fail: u32, zfail: u32, zpass: u32) -> ();
    fn TexImageDOM(&self, target: u32, level: i32, internalformat: u32, width: i32, height: i32, format: u32, type_: u32, source: &HTMLIFrameElement<TH>) -> Fallible<(), TH>;
    fn TexParameterf(&self, target: u32, pname: u32, param: f32) -> ();
    fn TexParameteri(&self, target: u32, pname: u32, param: i32) -> ();
    fn Uniform1f(&self, location: Option<&WebGLUniformLocation<TH>>, x: f32) -> ();
    fn Uniform2f(&self, location: Option<&WebGLUniformLocation<TH>>, x: f32, y: f32) -> ();
    fn Uniform3f(&self, location: Option<&WebGLUniformLocation<TH>>, x: f32, y: f32, z: f32) -> ();
    fn Uniform4f(&self, location: Option<&WebGLUniformLocation<TH>>, x: f32, y: f32, z: f32, w: f32) -> ();
    fn Uniform1i(&self, location: Option<&WebGLUniformLocation<TH>>, x: i32) -> ();
    fn Uniform2i(&self, location: Option<&WebGLUniformLocation<TH>>, x: i32, y: i32) -> ();
    fn Uniform3i(&self, location: Option<&WebGLUniformLocation<TH>>, x: i32, y: i32, z: i32) -> ();
    fn Uniform4i(&self, location: Option<&WebGLUniformLocation<TH>>, x: i32, y: i32, z: i32, w: i32) -> ();
    fn Uniform1fv(&self, location: Option<&WebGLUniformLocation<TH>>, v: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn Uniform2fv(&self, location: Option<&WebGLUniformLocation<TH>>, v: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn Uniform3fv(&self, location: Option<&WebGLUniformLocation<TH>>, v: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn Uniform4fv(&self, location: Option<&WebGLUniformLocation<TH>>, v: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn Uniform1iv(&self, location: Option<&WebGLUniformLocation<TH>>, v: UnionTypes::Int32ArrayOrLongSequence) -> ();
    fn Uniform2iv(&self, location: Option<&WebGLUniformLocation<TH>>, v: UnionTypes::Int32ArrayOrLongSequence) -> ();
    fn Uniform3iv(&self, location: Option<&WebGLUniformLocation<TH>>, v: UnionTypes::Int32ArrayOrLongSequence) -> ();
    fn Uniform4iv(&self, location: Option<&WebGLUniformLocation<TH>>, v: UnionTypes::Int32ArrayOrLongSequence) -> ();
    fn UniformMatrix2fv(&self, location: Option<&WebGLUniformLocation<TH>>, transpose: bool, value: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn UniformMatrix3fv(&self, location: Option<&WebGLUniformLocation<TH>>, transpose: bool, value: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn UniformMatrix4fv(&self, location: Option<&WebGLUniformLocation<TH>>, transpose: bool, value: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn UseProgram(&self, program: Option<&WebGLProgram<TH>>) -> ();
    fn ValidateProgram(&self, program: &WebGLProgram<TH>) -> ();
    fn VertexAttrib1f(&self, indx: u32, x: f32) -> ();
    fn VertexAttrib2f(&self, indx: u32, x: f32, y: f32) -> ();
    fn VertexAttrib3f(&self, indx: u32, x: f32, y: f32, z: f32) -> ();
    fn VertexAttrib4f(&self, indx: u32, x: f32, y: f32, z: f32, w: f32) -> ();
    fn VertexAttrib1fv(&self, indx: u32, values: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn VertexAttrib2fv(&self, indx: u32, values: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn VertexAttrib3fv(&self, indx: u32, values: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn VertexAttrib4fv(&self, indx: u32, values: UnionTypes::Float32ArrayOrUnrestrictedFloatSequence) -> ();
    fn VertexAttribPointer(&self, indx: u32, size: i32, type_: u32, normalized: bool, stride: i32, offset: i64) -> ();
    fn Viewport(&self, x: i32, y: i32, width: i32, height: i32) -> ();
}
fn sMethods_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSFunctionSpec]] { &[
&[
    JSFunctionSpec {
        name: b"bufferData\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &bufferData_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"bufferSubData\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &bufferSubData_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"texImage2D\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &texImage2D_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 6,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"texSubImage2D\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &texSubImage2D_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 7,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"readPixels\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &readPixels_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 7,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getContextAttributes\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getContextAttributes_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getSupportedExtensions\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getSupportedExtensions_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getExtension\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getExtension_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"activeTexture\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &activeTexture_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"attachShader\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &attachShader_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"bindAttribLocation\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &bindAttribLocation_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"bindBuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &bindBuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"bindFramebuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &bindFramebuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"bindRenderbuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &bindRenderbuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"bindTexture\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &bindTexture_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"blendColor\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &blendColor_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"blendEquation\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &blendEquation_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"blendEquationSeparate\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &blendEquationSeparate_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"blendFunc\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &blendFunc_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"blendFuncSeparate\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &blendFuncSeparate_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"checkFramebufferStatus\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &checkFramebufferStatus_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clear\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clear_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clearColor\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clearColor_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clearDepth\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clearDepth_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"clearStencil\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &clearStencil_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"colorMask\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &colorMask_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"compileShader\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &compileShader_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"compressedTexImage2D\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &compressedTexImage2D_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 7,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"compressedTexSubImage2D\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &compressedTexSubImage2D_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 8,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"copyTexImage2D\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &copyTexImage2D_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 8,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"copyTexSubImage2D\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &copyTexSubImage2D_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 8,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createBuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createBuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createFramebuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createFramebuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createProgram\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createProgram_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createRenderbuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createRenderbuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createShader\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createShader_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"createTexture\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &createTexture_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"cullFace\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &cullFace_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"deleteBuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &deleteBuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"deleteFramebuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &deleteFramebuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"deleteProgram\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &deleteProgram_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"deleteRenderbuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &deleteRenderbuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"deleteShader\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &deleteShader_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"deleteTexture\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &deleteTexture_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"depthFunc\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &depthFunc_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"depthMask\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &depthMask_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"depthRange\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &depthRange_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"detachShader\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &detachShader_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"disable\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &disable_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"disableVertexAttribArray\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &disableVertexAttribArray_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"drawArrays\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &drawArrays_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"drawElements\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &drawElements_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"enable\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &enable_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"enableVertexAttribArray\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &enableVertexAttribArray_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"finish\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &finish_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"flush\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &flush_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"framebufferRenderbuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &framebufferRenderbuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"framebufferTexture2D\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &framebufferTexture2D_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 5,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"frontFace\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &frontFace_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"generateMipmap\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &generateMipmap_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getActiveAttrib\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getActiveAttrib_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getActiveUniform\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getActiveUniform_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getAttachedShaders\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getAttachedShaders_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getAttribLocation\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getAttribLocation_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getBufferParameter\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getBufferParameter_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getParameter\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getParameter_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getError\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getError_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 0,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getFramebufferAttachmentParameter\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getFramebufferAttachmentParameter_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getProgramParameter\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getProgramParameter_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getProgramInfoLog\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getProgramInfoLog_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getRenderbufferParameter\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getRenderbufferParameter_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getShaderParameter\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getShaderParameter_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getShaderPrecisionFormat\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getShaderPrecisionFormat_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getShaderInfoLog\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getShaderInfoLog_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getShaderSource\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getShaderSource_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getTexParameter\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getTexParameter_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getUniformLocation\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getUniformLocation_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getVertexAttrib\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getVertexAttrib_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"getVertexAttribOffset\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &getVertexAttribOffset_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"hint\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &hint_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isBuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isBuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isEnabled\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isEnabled_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isFramebuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isFramebuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isProgram\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isProgram_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isRenderbuffer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isRenderbuffer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isShader\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isShader_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"isTexture\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &isTexture_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"lineWidth\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &lineWidth_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"linkProgram\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &linkProgram_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"pixelStorei\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &pixelStorei_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"polygonOffset\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &polygonOffset_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"renderbufferStorage\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &renderbufferStorage_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"sampleCoverage\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &sampleCoverage_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"scissor\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &scissor_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"shaderSource\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &shaderSource_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"stencilFunc\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &stencilFunc_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"stencilFuncSeparate\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &stencilFuncSeparate_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"stencilMask\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &stencilMask_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"stencilMaskSeparate\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &stencilMaskSeparate_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"stencilOp\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &stencilOp_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"stencilOpSeparate\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &stencilOpSeparate_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"texImageDOM\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &texImageDOM_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 8,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]
,
&[
    JSFunctionSpec {
        name: b"texParameterf\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &texParameterf_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"texParameteri\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &texParameteri_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform1f\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform1f_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform2f\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform2f_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform3f\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform3f_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform4f\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform4f_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 5,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform1i\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform1i_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform2i\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform2i_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform3i\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform3i_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform4i\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform4i_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 5,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform1fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform1fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform2fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform2fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform3fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform3fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform4fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform4fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform1iv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform1iv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform2iv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform2iv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform3iv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform3iv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniform4iv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniform4iv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniformMatrix2fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniformMatrix2fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniformMatrix3fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniformMatrix3fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"uniformMatrix4fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &uniformMatrix4fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"useProgram\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &useProgram_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"validateProgram\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &validateProgram_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 1,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"vertexAttrib1f\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &vertexAttrib1f_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"vertexAttrib2f\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &vertexAttrib2f_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 3,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"vertexAttrib3f\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &vertexAttrib3f_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"vertexAttrib4f\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &vertexAttrib4f_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 5,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"vertexAttrib1fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &vertexAttrib1fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"vertexAttrib2fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &vertexAttrib2fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"vertexAttrib3fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &vertexAttrib3fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"vertexAttrib4fv\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &vertexAttrib4fv_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 2,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"vertexAttribPointer\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &vertexAttribPointer_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 6,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: b"viewport\0" as *const u8 as *const libc::c_char,
        call: JSNativeWrapper { op: Some(generic_method), info: &viewport_methodinfo::<TH>() as *const _ as *const JSJitInfo },
        nargs: 4,
        flags: (JSPROP_ENUMERATE) as u16,
        selfHostedName: 0 as *const libc::c_char
    },
    JSFunctionSpec {
        name: 0 as *const libc::c_char,
        call: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        nargs: 0,
        flags: 0,
        selfHostedName: 0 as *const libc::c_char
    }]

]}
fn sMethods<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSFunctionSpec]>] { &[
    Guard::new(Condition::Satisfied, sMethods_specs::<TH>()[0]),
    Guard::new(Condition::Pref("dom.webgl.dom_to_texture.enabled"), sMethods_specs::<TH>()[1]),
    Guard::new(Condition::Satisfied, sMethods_specs::<TH>()[2])
]}
fn sAttributes_specs<TH: TypeHolderTrait>() -> &'static [&'static[JSPropertySpec]] { &[
&[
    JSPropertySpec {
        name: b"canvas\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &canvas_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"drawingBufferWidth\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &drawingBufferWidth_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: b"drawingBufferHeight\0" as *const u8 as *const libc::c_char,
        flags: (JSPROP_ENUMERATE | JSPROP_SHARED) as u8,
        getter: JSNativeWrapper { op: Some(generic_getter), info: &drawingBufferHeight_getterinfo::<TH>() },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    },
    JSPropertySpec {
        name: 0 as *const libc::c_char,
        flags: 0,
        getter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo },
        setter: JSNativeWrapper { op: None, info: 0 as *const JSJitInfo }
    }]

]}
fn sAttributes<TH: TypeHolderTrait>() -> &'static [Guard<&'static [JSPropertySpec]>] { &[
    Guard::new(Condition::Satisfied, sAttributes_specs::<TH>()[0])
]}
const sConstants_specs: &'static [&'static[ConstantSpec]] = &[
&[
    ConstantSpec { name: b"READ_BUFFER\0", value: ConstantVal::UintVal(3074) },
    ConstantSpec { name: b"UNPACK_ROW_LENGTH\0", value: ConstantVal::UintVal(3314) },
    ConstantSpec { name: b"UNPACK_SKIP_ROWS\0", value: ConstantVal::UintVal(3315) },
    ConstantSpec { name: b"UNPACK_SKIP_PIXELS\0", value: ConstantVal::UintVal(3316) },
    ConstantSpec { name: b"PACK_ROW_LENGTH\0", value: ConstantVal::UintVal(3330) },
    ConstantSpec { name: b"PACK_SKIP_ROWS\0", value: ConstantVal::UintVal(3331) },
    ConstantSpec { name: b"PACK_SKIP_PIXELS\0", value: ConstantVal::UintVal(3332) },
    ConstantSpec { name: b"COLOR\0", value: ConstantVal::UintVal(6144) },
    ConstantSpec { name: b"DEPTH\0", value: ConstantVal::UintVal(6145) },
    ConstantSpec { name: b"STENCIL\0", value: ConstantVal::UintVal(6146) },
    ConstantSpec { name: b"RED\0", value: ConstantVal::UintVal(6403) },
    ConstantSpec { name: b"RGB8\0", value: ConstantVal::UintVal(32849) },
    ConstantSpec { name: b"RGBA8\0", value: ConstantVal::UintVal(32856) },
    ConstantSpec { name: b"RGB10_A2\0", value: ConstantVal::UintVal(32857) },
    ConstantSpec { name: b"TEXTURE_BINDING_3D\0", value: ConstantVal::UintVal(32874) },
    ConstantSpec { name: b"UNPACK_SKIP_IMAGES\0", value: ConstantVal::UintVal(32877) },
    ConstantSpec { name: b"UNPACK_IMAGE_HEIGHT\0", value: ConstantVal::UintVal(32878) },
    ConstantSpec { name: b"TEXTURE_3D\0", value: ConstantVal::UintVal(32879) },
    ConstantSpec { name: b"TEXTURE_WRAP_R\0", value: ConstantVal::UintVal(32882) },
    ConstantSpec { name: b"MAX_3D_TEXTURE_SIZE\0", value: ConstantVal::UintVal(32883) },
    ConstantSpec { name: b"UNSIGNED_INT_2_10_10_10_REV\0", value: ConstantVal::UintVal(33640) },
    ConstantSpec { name: b"MAX_ELEMENTS_VERTICES\0", value: ConstantVal::UintVal(33000) },
    ConstantSpec { name: b"MAX_ELEMENTS_INDICES\0", value: ConstantVal::UintVal(33001) },
    ConstantSpec { name: b"TEXTURE_MIN_LOD\0", value: ConstantVal::UintVal(33082) },
    ConstantSpec { name: b"TEXTURE_MAX_LOD\0", value: ConstantVal::UintVal(33083) },
    ConstantSpec { name: b"TEXTURE_BASE_LEVEL\0", value: ConstantVal::UintVal(33084) },
    ConstantSpec { name: b"TEXTURE_MAX_LEVEL\0", value: ConstantVal::UintVal(33085) },
    ConstantSpec { name: b"MIN\0", value: ConstantVal::UintVal(32775) },
    ConstantSpec { name: b"MAX\0", value: ConstantVal::UintVal(32776) },
    ConstantSpec { name: b"DEPTH_COMPONENT24\0", value: ConstantVal::UintVal(33190) },
    ConstantSpec { name: b"MAX_TEXTURE_LOD_BIAS\0", value: ConstantVal::UintVal(34045) },
    ConstantSpec { name: b"TEXTURE_COMPARE_MODE\0", value: ConstantVal::UintVal(34892) },
    ConstantSpec { name: b"TEXTURE_COMPARE_FUNC\0", value: ConstantVal::UintVal(34893) },
    ConstantSpec { name: b"CURRENT_QUERY\0", value: ConstantVal::UintVal(34917) },
    ConstantSpec { name: b"QUERY_RESULT\0", value: ConstantVal::UintVal(34918) },
    ConstantSpec { name: b"QUERY_RESULT_AVAILABLE\0", value: ConstantVal::UintVal(34919) },
    ConstantSpec { name: b"STREAM_READ\0", value: ConstantVal::UintVal(35041) },
    ConstantSpec { name: b"STREAM_COPY\0", value: ConstantVal::UintVal(35042) },
    ConstantSpec { name: b"STATIC_READ\0", value: ConstantVal::UintVal(35045) },
    ConstantSpec { name: b"STATIC_COPY\0", value: ConstantVal::UintVal(35046) },
    ConstantSpec { name: b"DYNAMIC_READ\0", value: ConstantVal::UintVal(35049) },
    ConstantSpec { name: b"DYNAMIC_COPY\0", value: ConstantVal::UintVal(35050) },
    ConstantSpec { name: b"MAX_DRAW_BUFFERS\0", value: ConstantVal::UintVal(34852) },
    ConstantSpec { name: b"DRAW_BUFFER0\0", value: ConstantVal::UintVal(34853) },
    ConstantSpec { name: b"DRAW_BUFFER1\0", value: ConstantVal::UintVal(34854) },
    ConstantSpec { name: b"DRAW_BUFFER2\0", value: ConstantVal::UintVal(34855) },
    ConstantSpec { name: b"DRAW_BUFFER3\0", value: ConstantVal::UintVal(34856) },
    ConstantSpec { name: b"DRAW_BUFFER4\0", value: ConstantVal::UintVal(34857) },
    ConstantSpec { name: b"DRAW_BUFFER5\0", value: ConstantVal::UintVal(34858) },
    ConstantSpec { name: b"DRAW_BUFFER6\0", value: ConstantVal::UintVal(34859) },
    ConstantSpec { name: b"DRAW_BUFFER7\0", value: ConstantVal::UintVal(34860) },
    ConstantSpec { name: b"DRAW_BUFFER8\0", value: ConstantVal::UintVal(34861) },
    ConstantSpec { name: b"DRAW_BUFFER9\0", value: ConstantVal::UintVal(34862) },
    ConstantSpec { name: b"DRAW_BUFFER10\0", value: ConstantVal::UintVal(34863) },
    ConstantSpec { name: b"DRAW_BUFFER11\0", value: ConstantVal::UintVal(34864) },
    ConstantSpec { name: b"DRAW_BUFFER12\0", value: ConstantVal::UintVal(34865) },
    ConstantSpec { name: b"DRAW_BUFFER13\0", value: ConstantVal::UintVal(34866) },
    ConstantSpec { name: b"DRAW_BUFFER14\0", value: ConstantVal::UintVal(34867) },
    ConstantSpec { name: b"DRAW_BUFFER15\0", value: ConstantVal::UintVal(34868) },
    ConstantSpec { name: b"MAX_FRAGMENT_UNIFORM_COMPONENTS\0", value: ConstantVal::UintVal(35657) },
    ConstantSpec { name: b"MAX_VERTEX_UNIFORM_COMPONENTS\0", value: ConstantVal::UintVal(35658) },
    ConstantSpec { name: b"SAMPLER_3D\0", value: ConstantVal::UintVal(35679) },
    ConstantSpec { name: b"SAMPLER_2D_SHADOW\0", value: ConstantVal::UintVal(35682) },
    ConstantSpec { name: b"FRAGMENT_SHADER_DERIVATIVE_HINT\0", value: ConstantVal::UintVal(35723) },
    ConstantSpec { name: b"PIXEL_PACK_BUFFER\0", value: ConstantVal::UintVal(35051) },
    ConstantSpec { name: b"PIXEL_UNPACK_BUFFER\0", value: ConstantVal::UintVal(35052) },
    ConstantSpec { name: b"PIXEL_PACK_BUFFER_BINDING\0", value: ConstantVal::UintVal(35053) },
    ConstantSpec { name: b"PIXEL_UNPACK_BUFFER_BINDING\0", value: ConstantVal::UintVal(35055) },
    ConstantSpec { name: b"FLOAT_MAT2x3\0", value: ConstantVal::UintVal(35685) },
    ConstantSpec { name: b"FLOAT_MAT2x4\0", value: ConstantVal::UintVal(35686) },
    ConstantSpec { name: b"FLOAT_MAT3x2\0", value: ConstantVal::UintVal(35687) },
    ConstantSpec { name: b"FLOAT_MAT3x4\0", value: ConstantVal::UintVal(35688) },
    ConstantSpec { name: b"FLOAT_MAT4x2\0", value: ConstantVal::UintVal(35689) },
    ConstantSpec { name: b"FLOAT_MAT4x3\0", value: ConstantVal::UintVal(35690) },
    ConstantSpec { name: b"SRGB\0", value: ConstantVal::UintVal(35904) },
    ConstantSpec { name: b"SRGB8\0", value: ConstantVal::UintVal(35905) },
    ConstantSpec { name: b"SRGB8_ALPHA8\0", value: ConstantVal::UintVal(35907) },
    ConstantSpec { name: b"COMPARE_REF_TO_TEXTURE\0", value: ConstantVal::UintVal(34894) },
    ConstantSpec { name: b"RGBA32F\0", value: ConstantVal::UintVal(34836) },
    ConstantSpec { name: b"RGB32F\0", value: ConstantVal::UintVal(34837) },
    ConstantSpec { name: b"RGBA16F\0", value: ConstantVal::UintVal(34842) },
    ConstantSpec { name: b"RGB16F\0", value: ConstantVal::UintVal(34843) },
    ConstantSpec { name: b"VERTEX_ATTRIB_ARRAY_INTEGER\0", value: ConstantVal::UintVal(35069) },
    ConstantSpec { name: b"MAX_ARRAY_TEXTURE_LAYERS\0", value: ConstantVal::UintVal(35071) },
    ConstantSpec { name: b"MIN_PROGRAM_TEXEL_OFFSET\0", value: ConstantVal::UintVal(35076) },
    ConstantSpec { name: b"MAX_PROGRAM_TEXEL_OFFSET\0", value: ConstantVal::UintVal(35077) },
    ConstantSpec { name: b"MAX_VARYING_COMPONENTS\0", value: ConstantVal::UintVal(35659) },
    ConstantSpec { name: b"TEXTURE_2D_ARRAY\0", value: ConstantVal::UintVal(35866) },
    ConstantSpec { name: b"TEXTURE_BINDING_2D_ARRAY\0", value: ConstantVal::UintVal(35869) },
    ConstantSpec { name: b"R11F_G11F_B10F\0", value: ConstantVal::UintVal(35898) },
    ConstantSpec { name: b"UNSIGNED_INT_10F_11F_11F_REV\0", value: ConstantVal::UintVal(35899) },
    ConstantSpec { name: b"RGB9_E5\0", value: ConstantVal::UintVal(35901) },
    ConstantSpec { name: b"UNSIGNED_INT_5_9_9_9_REV\0", value: ConstantVal::UintVal(35902) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK_BUFFER_MODE\0", value: ConstantVal::UintVal(35967) },
    ConstantSpec { name: b"MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS\0", value: ConstantVal::UintVal(35968) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK_VARYINGS\0", value: ConstantVal::UintVal(35971) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK_BUFFER_START\0", value: ConstantVal::UintVal(35972) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK_BUFFER_SIZE\0", value: ConstantVal::UintVal(35973) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN\0", value: ConstantVal::UintVal(35976) },
    ConstantSpec { name: b"RASTERIZER_DISCARD\0", value: ConstantVal::UintVal(35977) },
    ConstantSpec { name: b"MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS\0", value: ConstantVal::UintVal(35978) },
    ConstantSpec { name: b"MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS\0", value: ConstantVal::UintVal(35979) },
    ConstantSpec { name: b"INTERLEAVED_ATTRIBS\0", value: ConstantVal::UintVal(35980) },
    ConstantSpec { name: b"SEPARATE_ATTRIBS\0", value: ConstantVal::UintVal(35981) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK_BUFFER\0", value: ConstantVal::UintVal(35982) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK_BUFFER_BINDING\0", value: ConstantVal::UintVal(35983) },
    ConstantSpec { name: b"RGBA32UI\0", value: ConstantVal::UintVal(36208) },
    ConstantSpec { name: b"RGB32UI\0", value: ConstantVal::UintVal(36209) },
    ConstantSpec { name: b"RGBA16UI\0", value: ConstantVal::UintVal(36214) },
    ConstantSpec { name: b"RGB16UI\0", value: ConstantVal::UintVal(36215) },
    ConstantSpec { name: b"RGBA8UI\0", value: ConstantVal::UintVal(36220) },
    ConstantSpec { name: b"RGB8UI\0", value: ConstantVal::UintVal(36221) },
    ConstantSpec { name: b"RGBA32I\0", value: ConstantVal::UintVal(36226) },
    ConstantSpec { name: b"RGB32I\0", value: ConstantVal::UintVal(36227) },
    ConstantSpec { name: b"RGBA16I\0", value: ConstantVal::UintVal(36232) },
    ConstantSpec { name: b"RGB16I\0", value: ConstantVal::UintVal(36233) },
    ConstantSpec { name: b"RGBA8I\0", value: ConstantVal::UintVal(36238) },
    ConstantSpec { name: b"RGB8I\0", value: ConstantVal::UintVal(36239) },
    ConstantSpec { name: b"RED_INTEGER\0", value: ConstantVal::UintVal(36244) },
    ConstantSpec { name: b"RGB_INTEGER\0", value: ConstantVal::UintVal(36248) },
    ConstantSpec { name: b"RGBA_INTEGER\0", value: ConstantVal::UintVal(36249) },
    ConstantSpec { name: b"SAMPLER_2D_ARRAY\0", value: ConstantVal::UintVal(36289) },
    ConstantSpec { name: b"SAMPLER_2D_ARRAY_SHADOW\0", value: ConstantVal::UintVal(36292) },
    ConstantSpec { name: b"SAMPLER_CUBE_SHADOW\0", value: ConstantVal::UintVal(36293) },
    ConstantSpec { name: b"UNSIGNED_INT_VEC2\0", value: ConstantVal::UintVal(36294) },
    ConstantSpec { name: b"UNSIGNED_INT_VEC3\0", value: ConstantVal::UintVal(36295) },
    ConstantSpec { name: b"UNSIGNED_INT_VEC4\0", value: ConstantVal::UintVal(36296) },
    ConstantSpec { name: b"INT_SAMPLER_2D\0", value: ConstantVal::UintVal(36298) },
    ConstantSpec { name: b"INT_SAMPLER_3D\0", value: ConstantVal::UintVal(36299) },
    ConstantSpec { name: b"INT_SAMPLER_CUBE\0", value: ConstantVal::UintVal(36300) },
    ConstantSpec { name: b"INT_SAMPLER_2D_ARRAY\0", value: ConstantVal::UintVal(36303) },
    ConstantSpec { name: b"UNSIGNED_INT_SAMPLER_2D\0", value: ConstantVal::UintVal(36306) },
    ConstantSpec { name: b"UNSIGNED_INT_SAMPLER_3D\0", value: ConstantVal::UintVal(36307) },
    ConstantSpec { name: b"UNSIGNED_INT_SAMPLER_CUBE\0", value: ConstantVal::UintVal(36308) },
    ConstantSpec { name: b"UNSIGNED_INT_SAMPLER_2D_ARRAY\0", value: ConstantVal::UintVal(36311) },
    ConstantSpec { name: b"DEPTH_COMPONENT32F\0", value: ConstantVal::UintVal(36012) },
    ConstantSpec { name: b"DEPTH32F_STENCIL8\0", value: ConstantVal::UintVal(36013) },
    ConstantSpec { name: b"FLOAT_32_UNSIGNED_INT_24_8_REV\0", value: ConstantVal::UintVal(36269) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING\0", value: ConstantVal::UintVal(33296) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE\0", value: ConstantVal::UintVal(33297) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_RED_SIZE\0", value: ConstantVal::UintVal(33298) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_GREEN_SIZE\0", value: ConstantVal::UintVal(33299) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_BLUE_SIZE\0", value: ConstantVal::UintVal(33300) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE\0", value: ConstantVal::UintVal(33301) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE\0", value: ConstantVal::UintVal(33302) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE\0", value: ConstantVal::UintVal(33303) },
    ConstantSpec { name: b"FRAMEBUFFER_DEFAULT\0", value: ConstantVal::UintVal(33304) },
    ConstantSpec { name: b"UNSIGNED_INT_24_8\0", value: ConstantVal::UintVal(34042) },
    ConstantSpec { name: b"DEPTH24_STENCIL8\0", value: ConstantVal::UintVal(35056) },
    ConstantSpec { name: b"UNSIGNED_NORMALIZED\0", value: ConstantVal::UintVal(35863) },
    ConstantSpec { name: b"DRAW_FRAMEBUFFER_BINDING\0", value: ConstantVal::UintVal(36006) },
    ConstantSpec { name: b"READ_FRAMEBUFFER\0", value: ConstantVal::UintVal(36008) },
    ConstantSpec { name: b"DRAW_FRAMEBUFFER\0", value: ConstantVal::UintVal(36009) },
    ConstantSpec { name: b"READ_FRAMEBUFFER_BINDING\0", value: ConstantVal::UintVal(36010) },
    ConstantSpec { name: b"RENDERBUFFER_SAMPLES\0", value: ConstantVal::UintVal(36011) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER\0", value: ConstantVal::UintVal(36052) },
    ConstantSpec { name: b"MAX_COLOR_ATTACHMENTS\0", value: ConstantVal::UintVal(36063) },
    ConstantSpec { name: b"COLOR_ATTACHMENT1\0", value: ConstantVal::UintVal(36065) },
    ConstantSpec { name: b"COLOR_ATTACHMENT2\0", value: ConstantVal::UintVal(36066) },
    ConstantSpec { name: b"COLOR_ATTACHMENT3\0", value: ConstantVal::UintVal(36067) },
    ConstantSpec { name: b"COLOR_ATTACHMENT4\0", value: ConstantVal::UintVal(36068) },
    ConstantSpec { name: b"COLOR_ATTACHMENT5\0", value: ConstantVal::UintVal(36069) },
    ConstantSpec { name: b"COLOR_ATTACHMENT6\0", value: ConstantVal::UintVal(36070) },
    ConstantSpec { name: b"COLOR_ATTACHMENT7\0", value: ConstantVal::UintVal(36071) },
    ConstantSpec { name: b"COLOR_ATTACHMENT8\0", value: ConstantVal::UintVal(36072) },
    ConstantSpec { name: b"COLOR_ATTACHMENT9\0", value: ConstantVal::UintVal(36073) },
    ConstantSpec { name: b"COLOR_ATTACHMENT10\0", value: ConstantVal::UintVal(36074) },
    ConstantSpec { name: b"COLOR_ATTACHMENT11\0", value: ConstantVal::UintVal(36075) },
    ConstantSpec { name: b"COLOR_ATTACHMENT12\0", value: ConstantVal::UintVal(36076) },
    ConstantSpec { name: b"COLOR_ATTACHMENT13\0", value: ConstantVal::UintVal(36077) },
    ConstantSpec { name: b"COLOR_ATTACHMENT14\0", value: ConstantVal::UintVal(36078) },
    ConstantSpec { name: b"COLOR_ATTACHMENT15\0", value: ConstantVal::UintVal(36079) },
    ConstantSpec { name: b"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE\0", value: ConstantVal::UintVal(36182) },
    ConstantSpec { name: b"MAX_SAMPLES\0", value: ConstantVal::UintVal(36183) },
    ConstantSpec { name: b"HALF_FLOAT\0", value: ConstantVal::UintVal(5131) },
    ConstantSpec { name: b"RG\0", value: ConstantVal::UintVal(33319) },
    ConstantSpec { name: b"RG_INTEGER\0", value: ConstantVal::UintVal(33320) },
    ConstantSpec { name: b"R8\0", value: ConstantVal::UintVal(33321) },
    ConstantSpec { name: b"RG8\0", value: ConstantVal::UintVal(33323) },
    ConstantSpec { name: b"R16F\0", value: ConstantVal::UintVal(33325) },
    ConstantSpec { name: b"R32F\0", value: ConstantVal::UintVal(33326) },
    ConstantSpec { name: b"RG16F\0", value: ConstantVal::UintVal(33327) },
    ConstantSpec { name: b"RG32F\0", value: ConstantVal::UintVal(33328) },
    ConstantSpec { name: b"R8I\0", value: ConstantVal::UintVal(33329) },
    ConstantSpec { name: b"R8UI\0", value: ConstantVal::UintVal(33330) },
    ConstantSpec { name: b"R16I\0", value: ConstantVal::UintVal(33331) },
    ConstantSpec { name: b"R16UI\0", value: ConstantVal::UintVal(33332) },
    ConstantSpec { name: b"R32I\0", value: ConstantVal::UintVal(33333) },
    ConstantSpec { name: b"R32UI\0", value: ConstantVal::UintVal(33334) },
    ConstantSpec { name: b"RG8I\0", value: ConstantVal::UintVal(33335) },
    ConstantSpec { name: b"RG8UI\0", value: ConstantVal::UintVal(33336) },
    ConstantSpec { name: b"RG16I\0", value: ConstantVal::UintVal(33337) },
    ConstantSpec { name: b"RG16UI\0", value: ConstantVal::UintVal(33338) },
    ConstantSpec { name: b"RG32I\0", value: ConstantVal::UintVal(33339) },
    ConstantSpec { name: b"RG32UI\0", value: ConstantVal::UintVal(33340) },
    ConstantSpec { name: b"VERTEX_ARRAY_BINDING\0", value: ConstantVal::UintVal(34229) },
    ConstantSpec { name: b"R8_SNORM\0", value: ConstantVal::UintVal(36756) },
    ConstantSpec { name: b"RG8_SNORM\0", value: ConstantVal::UintVal(36757) },
    ConstantSpec { name: b"RGB8_SNORM\0", value: ConstantVal::UintVal(36758) },
    ConstantSpec { name: b"RGBA8_SNORM\0", value: ConstantVal::UintVal(36759) },
    ConstantSpec { name: b"SIGNED_NORMALIZED\0", value: ConstantVal::UintVal(36764) },
    ConstantSpec { name: b"COPY_READ_BUFFER\0", value: ConstantVal::UintVal(36662) },
    ConstantSpec { name: b"COPY_WRITE_BUFFER\0", value: ConstantVal::UintVal(36663) },
    ConstantSpec { name: b"COPY_READ_BUFFER_BINDING\0", value: ConstantVal::UintVal(36662) },
    ConstantSpec { name: b"COPY_WRITE_BUFFER_BINDING\0", value: ConstantVal::UintVal(36663) },
    ConstantSpec { name: b"UNIFORM_BUFFER\0", value: ConstantVal::UintVal(35345) },
    ConstantSpec { name: b"UNIFORM_BUFFER_BINDING\0", value: ConstantVal::UintVal(35368) },
    ConstantSpec { name: b"UNIFORM_BUFFER_START\0", value: ConstantVal::UintVal(35369) },
    ConstantSpec { name: b"UNIFORM_BUFFER_SIZE\0", value: ConstantVal::UintVal(35370) },
    ConstantSpec { name: b"MAX_VERTEX_UNIFORM_BLOCKS\0", value: ConstantVal::UintVal(35371) },
    ConstantSpec { name: b"MAX_FRAGMENT_UNIFORM_BLOCKS\0", value: ConstantVal::UintVal(35373) },
    ConstantSpec { name: b"MAX_COMBINED_UNIFORM_BLOCKS\0", value: ConstantVal::UintVal(35374) },
    ConstantSpec { name: b"MAX_UNIFORM_BUFFER_BINDINGS\0", value: ConstantVal::UintVal(35375) },
    ConstantSpec { name: b"MAX_UNIFORM_BLOCK_SIZE\0", value: ConstantVal::UintVal(35376) },
    ConstantSpec { name: b"MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS\0", value: ConstantVal::UintVal(35377) },
    ConstantSpec { name: b"MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS\0", value: ConstantVal::UintVal(35379) },
    ConstantSpec { name: b"UNIFORM_BUFFER_OFFSET_ALIGNMENT\0", value: ConstantVal::UintVal(35380) },
    ConstantSpec { name: b"ACTIVE_UNIFORM_BLOCKS\0", value: ConstantVal::UintVal(35382) },
    ConstantSpec { name: b"UNIFORM_TYPE\0", value: ConstantVal::UintVal(35383) },
    ConstantSpec { name: b"UNIFORM_SIZE\0", value: ConstantVal::UintVal(35384) },
    ConstantSpec { name: b"UNIFORM_BLOCK_INDEX\0", value: ConstantVal::UintVal(35386) },
    ConstantSpec { name: b"UNIFORM_OFFSET\0", value: ConstantVal::UintVal(35387) },
    ConstantSpec { name: b"UNIFORM_ARRAY_STRIDE\0", value: ConstantVal::UintVal(35388) },
    ConstantSpec { name: b"UNIFORM_MATRIX_STRIDE\0", value: ConstantVal::UintVal(35389) },
    ConstantSpec { name: b"UNIFORM_IS_ROW_MAJOR\0", value: ConstantVal::UintVal(35390) },
    ConstantSpec { name: b"UNIFORM_BLOCK_BINDING\0", value: ConstantVal::UintVal(35391) },
    ConstantSpec { name: b"UNIFORM_BLOCK_DATA_SIZE\0", value: ConstantVal::UintVal(35392) },
    ConstantSpec { name: b"UNIFORM_BLOCK_ACTIVE_UNIFORMS\0", value: ConstantVal::UintVal(35394) },
    ConstantSpec { name: b"UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES\0", value: ConstantVal::UintVal(35395) },
    ConstantSpec { name: b"UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER\0", value: ConstantVal::UintVal(35396) },
    ConstantSpec { name: b"UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER\0", value: ConstantVal::UintVal(35398) },
    ConstantSpec { name: b"INVALID_INDEX\0", value: ConstantVal::UintVal(4294967295) },
    ConstantSpec { name: b"MAX_VERTEX_OUTPUT_COMPONENTS\0", value: ConstantVal::UintVal(37154) },
    ConstantSpec { name: b"MAX_FRAGMENT_INPUT_COMPONENTS\0", value: ConstantVal::UintVal(37157) },
    ConstantSpec { name: b"MAX_SERVER_WAIT_TIMEOUT\0", value: ConstantVal::UintVal(37137) },
    ConstantSpec { name: b"OBJECT_TYPE\0", value: ConstantVal::UintVal(37138) },
    ConstantSpec { name: b"SYNC_CONDITION\0", value: ConstantVal::UintVal(37139) },
    ConstantSpec { name: b"SYNC_STATUS\0", value: ConstantVal::UintVal(37140) },
    ConstantSpec { name: b"SYNC_FLAGS\0", value: ConstantVal::UintVal(37141) },
    ConstantSpec { name: b"SYNC_FENCE\0", value: ConstantVal::UintVal(37142) },
    ConstantSpec { name: b"SYNC_GPU_COMMANDS_COMPLETE\0", value: ConstantVal::UintVal(37143) },
    ConstantSpec { name: b"UNSIGNALED\0", value: ConstantVal::UintVal(37144) },
    ConstantSpec { name: b"SIGNALED\0", value: ConstantVal::UintVal(37145) },
    ConstantSpec { name: b"ALREADY_SIGNALED\0", value: ConstantVal::UintVal(37146) },
    ConstantSpec { name: b"TIMEOUT_EXPIRED\0", value: ConstantVal::UintVal(37147) },
    ConstantSpec { name: b"CONDITION_SATISFIED\0", value: ConstantVal::UintVal(37148) },
    ConstantSpec { name: b"WAIT_FAILED\0", value: ConstantVal::UintVal(37149) },
    ConstantSpec { name: b"SYNC_FLUSH_COMMANDS_BIT\0", value: ConstantVal::UintVal(1) },
    ConstantSpec { name: b"VERTEX_ATTRIB_ARRAY_DIVISOR\0", value: ConstantVal::UintVal(35070) },
    ConstantSpec { name: b"ANY_SAMPLES_PASSED\0", value: ConstantVal::UintVal(35887) },
    ConstantSpec { name: b"ANY_SAMPLES_PASSED_CONSERVATIVE\0", value: ConstantVal::UintVal(36202) },
    ConstantSpec { name: b"SAMPLER_BINDING\0", value: ConstantVal::UintVal(35097) },
    ConstantSpec { name: b"RGB10_A2UI\0", value: ConstantVal::UintVal(36975) },
    ConstantSpec { name: b"INT_2_10_10_10_REV\0", value: ConstantVal::UintVal(36255) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK\0", value: ConstantVal::UintVal(36386) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK_PAUSED\0", value: ConstantVal::UintVal(36387) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK_ACTIVE\0", value: ConstantVal::UintVal(36388) },
    ConstantSpec { name: b"TRANSFORM_FEEDBACK_BINDING\0", value: ConstantVal::UintVal(36389) },
    ConstantSpec { name: b"TEXTURE_IMMUTABLE_FORMAT\0", value: ConstantVal::UintVal(37167) },
    ConstantSpec { name: b"MAX_ELEMENT_INDEX\0", value: ConstantVal::UintVal(36203) },
    ConstantSpec { name: b"TEXTURE_IMMUTABLE_LEVELS\0", value: ConstantVal::UintVal(33503) },
    ConstantSpec { name: b"TIMEOUT_IGNORED\0", value: ConstantVal::DoubleVal(-1 as f64) },
    ConstantSpec { name: b"MAX_CLIENT_WAIT_TIMEOUT_WEBGL\0", value: ConstantVal::UintVal(37447) },
    ConstantSpec { name: b"DEPTH_BUFFER_BIT\0", value: ConstantVal::UintVal(256) },
    ConstantSpec { name: b"STENCIL_BUFFER_BIT\0", value: ConstantVal::UintVal(1024) },
    ConstantSpec { name: b"COLOR_BUFFER_BIT\0", value: ConstantVal::UintVal(16384) },
    ConstantSpec { name: b"POINTS\0", value: ConstantVal::UintVal(0) },
    ConstantSpec { name: b"LINES\0", value: ConstantVal::UintVal(1) },
    ConstantSpec { name: b"LINE_LOOP\0", value: ConstantVal::UintVal(2) },
    ConstantSpec { name: b"LINE_STRIP\0", value: ConstantVal::UintVal(3) },
    ConstantSpec { name: b"TRIANGLES\0", value: ConstantVal::UintVal(4) },
    ConstantSpec { name: b"TRIANGLE_STRIP\0", value: ConstantVal::UintVal(5) },
    ConstantSpec { name: b"TRIANGLE_FAN\0", value: ConstantVal::UintVal(6) },
    ConstantSpec { name: b"ZERO\0", value: ConstantVal::UintVal(0) },
    ConstantSpec { name: b"ONE\0", value: ConstantVal::UintVal(1) },
    ConstantSpec { name: b"SRC_COLOR\0", value: ConstantVal::UintVal(768) },
    ConstantSpec { name: b"ONE_MINUS_SRC_COLOR\0", value: ConstantVal::UintVal(769) },
    ConstantSpec { name: b"SRC_ALPHA\0", value: ConstantVal::UintVal(770) },
    ConstantSpec { name: b"ONE_MINUS_SRC_ALPHA\0", value: ConstantVal::UintVal(771) },
    ConstantSpec { name: b"DST_ALPHA\0", value: ConstantVal::UintVal(772) },
    ConstantSpec { name: b"ONE_MINUS_DST_ALPHA\0", value: ConstantVal::UintVal(773) },
    ConstantSpec { name: b"DST_COLOR\0", value: ConstantVal::UintVal(774) },
    ConstantSpec { name: b"ONE_MINUS_DST_COLOR\0", value: ConstantVal::UintVal(775) },
    ConstantSpec { name: b"SRC_ALPHA_SATURATE\0", value: ConstantVal::UintVal(776) },
    ConstantSpec { name: b"FUNC_ADD\0", value: ConstantVal::UintVal(32774) },
    ConstantSpec { name: b"BLEND_EQUATION\0", value: ConstantVal::UintVal(32777) },
    ConstantSpec { name: b"BLEND_EQUATION_RGB\0", value: ConstantVal::UintVal(32777) },
    ConstantSpec { name: b"BLEND_EQUATION_ALPHA\0", value: ConstantVal::UintVal(34877) },
    ConstantSpec { name: b"FUNC_SUBTRACT\0", value: ConstantVal::UintVal(32778) },
    ConstantSpec { name: b"FUNC_REVERSE_SUBTRACT\0", value: ConstantVal::UintVal(32779) },
    ConstantSpec { name: b"BLEND_DST_RGB\0", value: ConstantVal::UintVal(32968) },
    ConstantSpec { name: b"BLEND_SRC_RGB\0", value: ConstantVal::UintVal(32969) },
    ConstantSpec { name: b"BLEND_DST_ALPHA\0", value: ConstantVal::UintVal(32970) },
    ConstantSpec { name: b"BLEND_SRC_ALPHA\0", value: ConstantVal::UintVal(32971) },
    ConstantSpec { name: b"CONSTANT_COLOR\0", value: ConstantVal::UintVal(32769) },
    ConstantSpec { name: b"ONE_MINUS_CONSTANT_COLOR\0", value: ConstantVal::UintVal(32770) },
    ConstantSpec { name: b"CONSTANT_ALPHA\0", value: ConstantVal::UintVal(32771) },
    ConstantSpec { name: b"ONE_MINUS_CONSTANT_ALPHA\0", value: ConstantVal::UintVal(32772) },
    ConstantSpec { name: b"BLEND_COLOR\0", value: ConstantVal::UintVal(32773) },
    ConstantSpec { name: b"ARRAY_BUFFER\0", value: ConstantVal::UintVal(34962) },
    ConstantSpec { name: b"ELEMENT_ARRAY_BUFFER\0", value: ConstantVal::UintVal(34963) },
    ConstantSpec { name: b"ARRAY_BUFFER_BINDING\0", value: ConstantVal::UintVal(34964) },
    ConstantSpec { name: b"ELEMENT_ARRAY_BUFFER_BINDING\0", value: ConstantVal::UintVal(34965) },
    ConstantSpec { name: b"STREAM_DRAW\0", value: ConstantVal::UintVal(35040) },
    ConstantSpec { name: b"STATIC_DRAW\0", value: ConstantVal::UintVal(35044) },
    ConstantSpec { name: b"DYNAMIC_DRAW\0", value: ConstantVal::UintVal(35048) },
    ConstantSpec { name: b"BUFFER_SIZE\0", value: ConstantVal::UintVal(34660) },
    ConstantSpec { name: b"BUFFER_USAGE\0", value: ConstantVal::UintVal(34661) },
    ConstantSpec { name: b"CURRENT_VERTEX_ATTRIB\0", value: ConstantVal::UintVal(34342) },
    ConstantSpec { name: b"FRONT\0", value: ConstantVal::UintVal(1028) },
    ConstantSpec { name: b"BACK\0", value: ConstantVal::UintVal(1029) },
    ConstantSpec { name: b"FRONT_AND_BACK\0", value: ConstantVal::UintVal(1032) },
    ConstantSpec { name: b"CULL_FACE\0", value: ConstantVal::UintVal(2884) },
    ConstantSpec { name: b"BLEND\0", value: ConstantVal::UintVal(3042) },
    ConstantSpec { name: b"DITHER\0", value: ConstantVal::UintVal(3024) },
    ConstantSpec { name: b"STENCIL_TEST\0", value: ConstantVal::UintVal(2960) },
    ConstantSpec { name: b"DEPTH_TEST\0", value: ConstantVal::UintVal(2929) },
    ConstantSpec { name: b"SCISSOR_TEST\0", value: ConstantVal::UintVal(3089) },
    ConstantSpec { name: b"POLYGON_OFFSET_FILL\0", value: ConstantVal::UintVal(32823) },
    ConstantSpec { name: b"SAMPLE_ALPHA_TO_COVERAGE\0", value: ConstantVal::UintVal(32926) },
    ConstantSpec { name: b"SAMPLE_COVERAGE\0", value: ConstantVal::UintVal(32928) },
    ConstantSpec { name: b"NO_ERROR\0", value: ConstantVal::UintVal(0) },
    ConstantSpec { name: b"INVALID_ENUM\0", value: ConstantVal::UintVal(1280) },
    ConstantSpec { name: b"INVALID_VALUE\0", value: ConstantVal::UintVal(1281) },
    ConstantSpec { name: b"INVALID_OPERATION\0", value: ConstantVal::UintVal(1282) },
    ConstantSpec { name: b"OUT_OF_MEMORY\0", value: ConstantVal::UintVal(1285) },
    ConstantSpec { name: b"CW\0", value: ConstantVal::UintVal(2304) },
    ConstantSpec { name: b"CCW\0", value: ConstantVal::UintVal(2305) },
    ConstantSpec { name: b"LINE_WIDTH\0", value: ConstantVal::UintVal(2849) },
    ConstantSpec { name: b"ALIASED_POINT_SIZE_RANGE\0", value: ConstantVal::UintVal(33901) },
    ConstantSpec { name: b"ALIASED_LINE_WIDTH_RANGE\0", value: ConstantVal::UintVal(33902) },
    ConstantSpec { name: b"CULL_FACE_MODE\0", value: ConstantVal::UintVal(2885) },
    ConstantSpec { name: b"FRONT_FACE\0", value: ConstantVal::UintVal(2886) },
    ConstantSpec { name: b"DEPTH_RANGE\0", value: ConstantVal::UintVal(2928) },
    ConstantSpec { name: b"DEPTH_WRITEMASK\0", value: ConstantVal::UintVal(2930) },
    ConstantSpec { name: b"DEPTH_CLEAR_VALUE\0", value: ConstantVal::UintVal(2931) },
    ConstantSpec { name: b"DEPTH_FUNC\0", value: ConstantVal::UintVal(2932) },
    ConstantSpec { name: b"STENCIL_CLEAR_VALUE\0", value: ConstantVal::UintVal(2961) },
    ConstantSpec { name: b"STENCIL_FUNC\0", value: ConstantVal::UintVal(2962) },
    ConstantSpec { name: b"STENCIL_FAIL\0", value: ConstantVal::UintVal(2964) },
    ConstantSpec { name: b"STENCIL_PASS_DEPTH_FAIL\0", value: ConstantVal::UintVal(2965) },
    ConstantSpec { name: b"STENCIL_PASS_DEPTH_PASS\0", value: ConstantVal::UintVal(2966) },
    ConstantSpec { name: b"STENCIL_REF\0", value: ConstantVal::UintVal(2967) },
    ConstantSpec { name: b"STENCIL_VALUE_MASK\0", value: ConstantVal::UintVal(2963) },
    ConstantSpec { name: b"STENCIL_WRITEMASK\0", value: ConstantVal::UintVal(2968) },
    ConstantSpec { name: b"STENCIL_BACK_FUNC\0", value: ConstantVal::UintVal(34816) },
    ConstantSpec { name: b"STENCIL_BACK_FAIL\0", value: ConstantVal::UintVal(34817) },
    ConstantSpec { name: b"STENCIL_BACK_PASS_DEPTH_FAIL\0", value: ConstantVal::UintVal(34818) },
    ConstantSpec { name: b"STENCIL_BACK_PASS_DEPTH_PASS\0", value: ConstantVal::UintVal(34819) },
    ConstantSpec { name: b"STENCIL_BACK_REF\0", value: ConstantVal::UintVal(36003) },
    ConstantSpec { name: b"STENCIL_BACK_VALUE_MASK\0", value: ConstantVal::UintVal(36004) },
    ConstantSpec { name: b"STENCIL_BACK_WRITEMASK\0", value: ConstantVal::UintVal(36005) },
    ConstantSpec { name: b"VIEWPORT\0", value: ConstantVal::UintVal(2978) },
    ConstantSpec { name: b"SCISSOR_BOX\0", value: ConstantVal::UintVal(3088) },
    ConstantSpec { name: b"COLOR_CLEAR_VALUE\0", value: ConstantVal::UintVal(3106) },
    ConstantSpec { name: b"COLOR_WRITEMASK\0", value: ConstantVal::UintVal(3107) },
    ConstantSpec { name: b"UNPACK_ALIGNMENT\0", value: ConstantVal::UintVal(3317) },
    ConstantSpec { name: b"PACK_ALIGNMENT\0", value: ConstantVal::UintVal(3333) },
    ConstantSpec { name: b"MAX_TEXTURE_SIZE\0", value: ConstantVal::UintVal(3379) },
    ConstantSpec { name: b"MAX_VIEWPORT_DIMS\0", value: ConstantVal::UintVal(3386) },
    ConstantSpec { name: b"SUBPIXEL_BITS\0", value: ConstantVal::UintVal(3408) },
    ConstantSpec { name: b"RED_BITS\0", value: ConstantVal::UintVal(3410) },
    ConstantSpec { name: b"GREEN_BITS\0", value: ConstantVal::UintVal(3411) },
    ConstantSpec { name: b"BLUE_BITS\0", value: ConstantVal::UintVal(3412) },
    ConstantSpec { name: b"ALPHA_BITS\0", value: ConstantVal::UintVal(3413) },
    ConstantSpec { name: b"DEPTH_BITS\0", value: ConstantVal::UintVal(3414) },
    ConstantSpec { name: b"STENCIL_BITS\0", value: ConstantVal::UintVal(3415) },
    ConstantSpec { name: b"POLYGON_OFFSET_UNITS\0", value: ConstantVal::UintVal(10752) },
    ConstantSpec { name: b"POLYGON_OFFSET_FACTOR\0", value: ConstantVal::UintVal(32824) },
    ConstantSpec { name: b"TEXTURE_BINDING_2D\0", value: ConstantVal::UintVal(32873) },
    ConstantSpec { name: b"SAMPLE_BUFFERS\0", value: ConstantVal::UintVal(32936) },
    ConstantSpec { name: b"SAMPLES\0", value: ConstantVal::UintVal(32937) },
    ConstantSpec { name: b"SAMPLE_COVERAGE_VALUE\0", value: ConstantVal::UintVal(32938) },
    ConstantSpec { name: b"SAMPLE_COVERAGE_INVERT\0", value: ConstantVal::UintVal(32939) },
    ConstantSpec { name: b"COMPRESSED_TEXTURE_FORMATS\0", value: ConstantVal::UintVal(34467) },
    ConstantSpec { name: b"DONT_CARE\0", value: ConstantVal::UintVal(4352) },
    ConstantSpec { name: b"FASTEST\0", value: ConstantVal::UintVal(4353) },
    ConstantSpec { name: b"NICEST\0", value: ConstantVal::UintVal(4354) },
    ConstantSpec { name: b"GENERATE_MIPMAP_HINT\0", value: ConstantVal::UintVal(33170) },
    ConstantSpec { name: b"BYTE\0", value: ConstantVal::UintVal(5120) },
    ConstantSpec { name: b"UNSIGNED_BYTE\0", value: ConstantVal::UintVal(5121) },
    ConstantSpec { name: b"SHORT\0", value: ConstantVal::UintVal(5122) },
    ConstantSpec { name: b"UNSIGNED_SHORT\0", value: ConstantVal::UintVal(5123) },
    ConstantSpec { name: b"INT\0", value: ConstantVal::UintVal(5124) },
    ConstantSpec { name: b"UNSIGNED_INT\0", value: ConstantVal::UintVal(5125) },
    ConstantSpec { name: b"FLOAT\0", value: ConstantVal::UintVal(5126) },
    ConstantSpec { name: b"DEPTH_COMPONENT\0", value: ConstantVal::UintVal(6402) },
    ConstantSpec { name: b"ALPHA\0", value: ConstantVal::UintVal(6406) },
    ConstantSpec { name: b"RGB\0", value: ConstantVal::UintVal(6407) },
    ConstantSpec { name: b"RGBA\0", value: ConstantVal::UintVal(6408) },
    ConstantSpec { name: b"LUMINANCE\0", value: ConstantVal::UintVal(6409) },
    ConstantSpec { name: b"LUMINANCE_ALPHA\0", value: ConstantVal::UintVal(6410) },
    ConstantSpec { name: b"UNSIGNED_SHORT_4_4_4_4\0", value: ConstantVal::UintVal(32819) },
    ConstantSpec { name: b"UNSIGNED_SHORT_5_5_5_1\0", value: ConstantVal::UintVal(32820) },
    ConstantSpec { name: b"UNSIGNED_SHORT_5_6_5\0", value: ConstantVal::UintVal(33635) },
    ConstantSpec { name: b"FRAGMENT_SHADER\0", value: ConstantVal::UintVal(35632) },
    ConstantSpec { name: b"VERTEX_SHADER\0", value: ConstantVal::UintVal(35633) },
    ConstantSpec { name: b"MAX_VERTEX_ATTRIBS\0", value: ConstantVal::UintVal(34921) },
    ConstantSpec { name: b"MAX_VERTEX_UNIFORM_VECTORS\0", value: ConstantVal::UintVal(36347) },
    ConstantSpec { name: b"MAX_VARYING_VECTORS\0", value: ConstantVal::UintVal(36348) },
    ConstantSpec { name: b"MAX_COMBINED_TEXTURE_IMAGE_UNITS\0", value: ConstantVal::UintVal(35661) },
    ConstantSpec { name: b"MAX_VERTEX_TEXTURE_IMAGE_UNITS\0", value: ConstantVal::UintVal(35660) },
    ConstantSpec { name: b"MAX_TEXTURE_IMAGE_UNITS\0", value: ConstantVal::UintVal(34930) },
    ConstantSpec { name: b"MAX_FRAGMENT_UNIFORM_VECTORS\0", value: ConstantVal::UintVal(36349) },
    ConstantSpec { name: b"SHADER_TYPE\0", value: ConstantVal::UintVal(35663) },
    ConstantSpec { name: b"DELETE_STATUS\0", value: ConstantVal::UintVal(35712) },
    ConstantSpec { name: b"LINK_STATUS\0", value: ConstantVal::UintVal(35714) },
    ConstantSpec { name: b"VALIDATE_STATUS\0", value: ConstantVal::UintVal(35715) },
    ConstantSpec { name: b"ATTACHED_SHADERS\0", value: ConstantVal::UintVal(35717) },
    ConstantSpec { name: b"ACTIVE_UNIFORMS\0", value: ConstantVal::UintVal(35718) },
    ConstantSpec { name: b"ACTIVE_ATTRIBUTES\0", value: ConstantVal::UintVal(35721) },
    ConstantSpec { name: b"SHADING_LANGUAGE_VERSION\0", value: ConstantVal::UintVal(35724) },
    ConstantSpec { name: b"CURRENT_PROGRAM\0", value: ConstantVal::UintVal(35725) },
    ConstantSpec { name: b"NEVER\0", value: ConstantVal::UintVal(512) },
    ConstantSpec { name: b"LESS\0", value: ConstantVal::UintVal(513) },
    ConstantSpec { name: b"EQUAL\0", value: ConstantVal::UintVal(514) },
    ConstantSpec { name: b"LEQUAL\0", value: ConstantVal::UintVal(515) },
    ConstantSpec { name: b"GREATER\0", value: ConstantVal::UintVal(516) },
    ConstantSpec { name: b"NOTEQUAL\0", value: ConstantVal::UintVal(517) },
    ConstantSpec { name: b"GEQUAL\0", value: ConstantVal::UintVal(518) },
    ConstantSpec { name: b"ALWAYS\0", value: ConstantVal::UintVal(519) },
    ConstantSpec { name: b"KEEP\0", value: ConstantVal::UintVal(7680) },
    ConstantSpec { name: b"REPLACE\0", value: ConstantVal::UintVal(7681) },
    ConstantSpec { name: b"INCR\0", value: ConstantVal::UintVal(7682) },
    ConstantSpec { name: b"DECR\0", value: ConstantVal::UintVal(7683) },
    ConstantSpec { name: b"INVERT\0", value: ConstantVal::UintVal(5386) },
    ConstantSpec { name: b"INCR_WRAP\0", value: ConstantVal::UintVal(34055) },
    ConstantSpec { name: b"DECR_WRAP\0", value: ConstantVal::UintVal(34056) },
    ConstantSpec { name: b"VENDOR\0", value: ConstantVal::UintVal(7936) },
    ConstantSpec { name: b"RENDERER\0", value: ConstantVal::UintVal(7937) },
    ConstantSpec { name: b"VERSION\0", value: ConstantVal::UintVal(7938) },
    ConstantSpec { name: b"NEAREST\0", value: ConstantVal::UintVal(9728) },
    ConstantSpec { name: b"LINEAR\0", value: ConstantVal::UintVal(9729) },
    ConstantSpec { name: b"NEAREST_MIPMAP_NEAREST\0", value: ConstantVal::UintVal(9984) },
    ConstantSpec { name: b"LINEAR_MIPMAP_NEAREST\0", value: ConstantVal::UintVal(9985) },
    ConstantSpec { name: b"NEAREST_MIPMAP_LINEAR\0", value: ConstantVal::UintVal(9986) },
    ConstantSpec { name: b"LINEAR_MIPMAP_LINEAR\0", value: ConstantVal::UintVal(9987) },
    ConstantSpec { name: b"TEXTURE_MAG_FILTER\0", value: ConstantVal::UintVal(10240) },
    ConstantSpec { name: b"TEXTURE_MIN_FILTER\0", value: ConstantVal::UintVal(10241) },
    ConstantSpec { name: b"TEXTURE_WRAP_S\0", value: ConstantVal::UintVal(10242) },
    ConstantSpec { name: b"TEXTURE_WRAP_T\0", value: ConstantVal::UintVal(10243) },
    ConstantSpec { name: b"TEXTURE_2D\0", value: ConstantVal::UintVal(3553) },
    ConstantSpec { name: b"TEXTURE\0", value: ConstantVal::UintVal(5890) },
    ConstantSpec { name: b"TEXTURE_CUBE_MAP\0", value: ConstantVal::UintVal(34067) },
    ConstantSpec { name: b"TEXTURE_BINDING_CUBE_MAP\0", value: ConstantVal::UintVal(34068) },
    ConstantSpec { name: b"TEXTURE_CUBE_MAP_POSITIVE_X\0", value: ConstantVal::UintVal(34069) },
    ConstantSpec { name: b"TEXTURE_CUBE_MAP_NEGATIVE_X\0", value: ConstantVal::UintVal(34070) },
    ConstantSpec { name: b"TEXTURE_CUBE_MAP_POSITIVE_Y\0", value: ConstantVal::UintVal(34071) },
    ConstantSpec { name: b"TEXTURE_CUBE_MAP_NEGATIVE_Y\0", value: ConstantVal::UintVal(34072) },
    ConstantSpec { name: b"TEXTURE_CUBE_MAP_POSITIVE_Z\0", value: ConstantVal::UintVal(34073) },
    ConstantSpec { name: b"TEXTURE_CUBE_MAP_NEGATIVE_Z\0", value: ConstantVal::UintVal(34074) },
    ConstantSpec { name: b"MAX_CUBE_MAP_TEXTURE_SIZE\0", value: ConstantVal::UintVal(34076) },
    ConstantSpec { name: b"TEXTURE0\0", value: ConstantVal::UintVal(33984) },
    ConstantSpec { name: b"TEXTURE1\0", value: ConstantVal::UintVal(33985) },
    ConstantSpec { name: b"TEXTURE2\0", value: ConstantVal::UintVal(33986) },
    ConstantSpec { name: b"TEXTURE3\0", value: ConstantVal::UintVal(33987) },
    ConstantSpec { name: b"TEXTURE4\0", value: ConstantVal::UintVal(33988) },
    ConstantSpec { name: b"TEXTURE5\0", value: ConstantVal::UintVal(33989) },
    ConstantSpec { name: b"TEXTURE6\0", value: ConstantVal::UintVal(33990) },
    ConstantSpec { name: b"TEXTURE7\0", value: ConstantVal::UintVal(33991) },
    ConstantSpec { name: b"TEXTURE8\0", value: ConstantVal::UintVal(33992) },
    ConstantSpec { name: b"TEXTURE9\0", value: ConstantVal::UintVal(33993) },
    ConstantSpec { name: b"TEXTURE10\0", value: ConstantVal::UintVal(33994) },
    ConstantSpec { name: b"TEXTURE11\0", value: ConstantVal::UintVal(33995) },
    ConstantSpec { name: b"TEXTURE12\0", value: ConstantVal::UintVal(33996) },
    ConstantSpec { name: b"TEXTURE13\0", value: ConstantVal::UintVal(33997) },
    ConstantSpec { name: b"TEXTURE14\0", value: ConstantVal::UintVal(33998) },
    ConstantSpec { name: b"TEXTURE15\0", value: ConstantVal::UintVal(33999) },
    ConstantSpec { name: b"TEXTURE16\0", value: ConstantVal::UintVal(34000) },
    ConstantSpec { name: b"TEXTURE17\0", value: ConstantVal::UintVal(34001) },
    ConstantSpec { name: b"TEXTURE18\0", value: ConstantVal::UintVal(34002) },
    ConstantSpec { name: b"TEXTURE19\0", value: ConstantVal::UintVal(34003) },
    ConstantSpec { name: b"TEXTURE20\0", value: ConstantVal::UintVal(34004) },
    ConstantSpec { name: b"TEXTURE21\0", value: ConstantVal::UintVal(34005) },
    ConstantSpec { name: b"TEXTURE22\0", value: ConstantVal::UintVal(34006) },
    ConstantSpec { name: b"TEXTURE23\0", value: ConstantVal::UintVal(34007) },
    ConstantSpec { name: b"TEXTURE24\0", value: ConstantVal::UintVal(34008) },
    ConstantSpec { name: b"TEXTURE25\0", value: ConstantVal::UintVal(34009) },
    ConstantSpec { name: b"TEXTURE26\0", value: ConstantVal::UintVal(34010) },
    ConstantSpec { name: b"TEXTURE27\0", value: ConstantVal::UintVal(34011) },
    ConstantSpec { name: b"TEXTURE28\0", value: ConstantVal::UintVal(34012) },
    ConstantSpec { name: b"TEXTURE29\0", value: ConstantVal::UintVal(34013) },
    ConstantSpec { name: b"TEXTURE30\0", value: ConstantVal::UintVal(34014) },
    ConstantSpec { name: b"TEXTURE31\0", value: ConstantVal::UintVal(34015) },
    ConstantSpec { name: b"ACTIVE_TEXTURE\0", value: ConstantVal::UintVal(34016) },
    ConstantSpec { name: b"REPEAT\0", value: ConstantVal::UintVal(10497) },
    ConstantSpec { name: b"CLAMP_TO_EDGE\0", value: ConstantVal::UintVal(33071) },
    ConstantSpec { name: b"MIRRORED_REPEAT\0", value: ConstantVal::UintVal(33648) },
    ConstantSpec { name: b"FLOAT_VEC2\0", value: ConstantVal::UintVal(35664) },
    ConstantSpec { name: b"FLOAT_VEC3\0", value: ConstantVal::UintVal(35665) },
    ConstantSpec { name: b"FLOAT_VEC4\0", value: ConstantVal::UintVal(35666) },
    ConstantSpec { name: b"INT_VEC2\0", value: ConstantVal::UintVal(35667) },
    ConstantSpec { name: b"INT_VEC3\0", value: ConstantVal::UintVal(35668) },
    ConstantSpec { name: b"INT_VEC4\0", value: ConstantVal::UintVal(35669) },
    ConstantSpec { name: b"BOOL\0", value: ConstantVal::UintVal(35670) },
    ConstantSpec { name: b"BOOL_VEC2\0", value: ConstantVal::UintVal(35671) },
    ConstantSpec { name: b"BOOL_VEC3\0", value: ConstantVal::UintVal(35672) },
    ConstantSpec { name: b"BOOL_VEC4\0", value: ConstantVal::UintVal(35673) },
    ConstantSpec { name: b"FLOAT_MAT2\0", value: ConstantVal::UintVal(35674) },
    ConstantSpec { name: b"FLOAT_MAT3\0", value: ConstantVal::UintVal(35675) },
    ConstantSpec { name: b"FLOAT_MAT4\0", value: ConstantVal::UintVal(35676) },
    ConstantSpec { name: b"SAMPLER_2D\0", value: ConstantVal::UintVal(35678) },
    ConstantSpec { name: b"SAMPLER_CUBE\0", value: ConstantVal::UintVal(35680) },
    ConstantSpec { name: b"VERTEX_ATTRIB_ARRAY_ENABLED\0", value: ConstantVal::UintVal(34338) },
    ConstantSpec { name: b"VERTEX_ATTRIB_ARRAY_SIZE\0", value: ConstantVal::UintVal(34339) },
    ConstantSpec { name: b"VERTEX_ATTRIB_ARRAY_STRIDE\0", value: ConstantVal::UintVal(34340) },
    ConstantSpec { name: b"VERTEX_ATTRIB_ARRAY_TYPE\0", value: ConstantVal::UintVal(34341) },
    ConstantSpec { name: b"VERTEX_ATTRIB_ARRAY_NORMALIZED\0", value: ConstantVal::UintVal(34922) },
    ConstantSpec { name: b"VERTEX_ATTRIB_ARRAY_POINTER\0", value: ConstantVal::UintVal(34373) },
    ConstantSpec { name: b"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING\0", value: ConstantVal::UintVal(34975) },
    ConstantSpec { name: b"IMPLEMENTATION_COLOR_READ_TYPE\0", value: ConstantVal::UintVal(35738) },
    ConstantSpec { name: b"IMPLEMENTATION_COLOR_READ_FORMAT\0", value: ConstantVal::UintVal(35739) },
    ConstantSpec { name: b"COMPILE_STATUS\0", value: ConstantVal::UintVal(35713) },
    ConstantSpec { name: b"LOW_FLOAT\0", value: ConstantVal::UintVal(36336) },
    ConstantSpec { name: b"MEDIUM_FLOAT\0", value: ConstantVal::UintVal(36337) },
    ConstantSpec { name: b"HIGH_FLOAT\0", value: ConstantVal::UintVal(36338) },
    ConstantSpec { name: b"LOW_INT\0", value: ConstantVal::UintVal(36339) },
    ConstantSpec { name: b"MEDIUM_INT\0", value: ConstantVal::UintVal(36340) },
    ConstantSpec { name: b"HIGH_INT\0", value: ConstantVal::UintVal(36341) },
    ConstantSpec { name: b"FRAMEBUFFER\0", value: ConstantVal::UintVal(36160) },
    ConstantSpec { name: b"RENDERBUFFER\0", value: ConstantVal::UintVal(36161) },
    ConstantSpec { name: b"RGBA4\0", value: ConstantVal::UintVal(32854) },
    ConstantSpec { name: b"RGB5_A1\0", value: ConstantVal::UintVal(32855) },
    ConstantSpec { name: b"RGB565\0", value: ConstantVal::UintVal(36194) },
    ConstantSpec { name: b"DEPTH_COMPONENT16\0", value: ConstantVal::UintVal(33189) },
    ConstantSpec { name: b"STENCIL_INDEX\0", value: ConstantVal::UintVal(6401) },
    ConstantSpec { name: b"STENCIL_INDEX8\0", value: ConstantVal::UintVal(36168) },
    ConstantSpec { name: b"DEPTH_STENCIL\0", value: ConstantVal::UintVal(34041) },
    ConstantSpec { name: b"RENDERBUFFER_WIDTH\0", value: ConstantVal::UintVal(36162) },
    ConstantSpec { name: b"RENDERBUFFER_HEIGHT\0", value: ConstantVal::UintVal(36163) },
    ConstantSpec { name: b"RENDERBUFFER_INTERNAL_FORMAT\0", value: ConstantVal::UintVal(36164) },
    ConstantSpec { name: b"RENDERBUFFER_RED_SIZE\0", value: ConstantVal::UintVal(36176) },
    ConstantSpec { name: b"RENDERBUFFER_GREEN_SIZE\0", value: ConstantVal::UintVal(36177) },
    ConstantSpec { name: b"RENDERBUFFER_BLUE_SIZE\0", value: ConstantVal::UintVal(36178) },
    ConstantSpec { name: b"RENDERBUFFER_ALPHA_SIZE\0", value: ConstantVal::UintVal(36179) },
    ConstantSpec { name: b"RENDERBUFFER_DEPTH_SIZE\0", value: ConstantVal::UintVal(36180) },
    ConstantSpec { name: b"RENDERBUFFER_STENCIL_SIZE\0", value: ConstantVal::UintVal(36181) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE\0", value: ConstantVal::UintVal(36048) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME\0", value: ConstantVal::UintVal(36049) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL\0", value: ConstantVal::UintVal(36050) },
    ConstantSpec { name: b"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE\0", value: ConstantVal::UintVal(36051) },
    ConstantSpec { name: b"COLOR_ATTACHMENT0\0", value: ConstantVal::UintVal(36064) },
    ConstantSpec { name: b"DEPTH_ATTACHMENT\0", value: ConstantVal::UintVal(36096) },
    ConstantSpec { name: b"STENCIL_ATTACHMENT\0", value: ConstantVal::UintVal(36128) },
    ConstantSpec { name: b"DEPTH_STENCIL_ATTACHMENT\0", value: ConstantVal::UintVal(33306) },
    ConstantSpec { name: b"NONE\0", value: ConstantVal::UintVal(0) },
    ConstantSpec { name: b"FRAMEBUFFER_COMPLETE\0", value: ConstantVal::UintVal(36053) },
    ConstantSpec { name: b"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\0", value: ConstantVal::UintVal(36054) },
    ConstantSpec { name: b"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\0", value: ConstantVal::UintVal(36055) },
    ConstantSpec { name: b"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\0", value: ConstantVal::UintVal(36057) },
    ConstantSpec { name: b"FRAMEBUFFER_UNSUPPORTED\0", value: ConstantVal::UintVal(36061) },
    ConstantSpec { name: b"FRAMEBUFFER_BINDING\0", value: ConstantVal::UintVal(36006) },
    ConstantSpec { name: b"RENDERBUFFER_BINDING\0", value: ConstantVal::UintVal(36007) },
    ConstantSpec { name: b"MAX_RENDERBUFFER_SIZE\0", value: ConstantVal::UintVal(34024) },
    ConstantSpec { name: b"INVALID_FRAMEBUFFER_OPERATION\0", value: ConstantVal::UintVal(1286) },
    ConstantSpec { name: b"UNPACK_FLIP_Y_WEBGL\0", value: ConstantVal::UintVal(37440) },
    ConstantSpec { name: b"UNPACK_PREMULTIPLY_ALPHA_WEBGL\0", value: ConstantVal::UintVal(37441) },
    ConstantSpec { name: b"CONTEXT_LOST_WEBGL\0", value: ConstantVal::UintVal(37442) },
    ConstantSpec { name: b"UNPACK_COLORSPACE_CONVERSION_WEBGL\0", value: ConstantVal::UintVal(37443) },
    ConstantSpec { name: b"BROWSER_DEFAULT_WEBGL\0", value: ConstantVal::UintVal(37444) }]

];
const sConstants: &'static [Guard<&'static [ConstantSpec]>] = &[
    Guard::new(Condition::Satisfied, sConstants_specs[0])
];

pub unsafe fn GetProtoObject<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, mut rval: MutableHandleObject) {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    assert!(((*get_object_class(global.get())).flags & JSCLASS_DOM_GLOBAL) != 0);

    /* Check to see whether the interface objects are already installed */
    let proto_or_iface_array = get_proto_or_iface_array(global.get());
    rval.set((*proto_or_iface_array)[PrototypeList::ID::WebGL2RenderingContext as usize]);
    if !rval.get().is_null() {
        return;
    }

    CreateInterfaceObjects(cx, global, proto_or_iface_array);
    rval.set((*proto_or_iface_array)[PrototypeList::ID::WebGL2RenderingContext as usize]);
    assert!(!rval.get().is_null());

}

static PrototypeClass: JSClass = JSClass {
    name: b"WebGL2RenderingContextPrototype\0" as *const u8 as *const libc::c_char,
    flags:
        // JSCLASS_HAS_RESERVED_SLOTS(0)
        (0 & JSCLASS_RESERVED_SLOTS_MASK) << JSCLASS_RESERVED_SLOTS_SHIFT,
    cOps: 0 as *const _,
    reserved: [0 as *mut os::raw::c_void; 3]
};

static INTERFACE_OBJECT_CLASS: NonCallbackInterfaceObjectClass =
    NonCallbackInterfaceObjectClass::new(
        &InterfaceConstructorBehavior::throw(),
        b"function WebGL2RenderingContext() {\n    [native code]\n}",
        PrototypeList::ID::WebGL2RenderingContext,
        0);

pub unsafe fn DefineDOMInterface<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject) {
    assert!(!global.get().is_null());

    if !ConstructorEnabled(cx, global) {
        return;
    }

    rooted!(in(cx) let mut proto = ptr::null_mut::<JSObject>());
    GetProtoObject(cx, global, proto.handle_mut());
    assert!(!proto.is_null());
}

unsafe fn ConstructorEnabled<TH: TypeHolderTrait>
(aCx: *mut JSContext, aObj: HandleObject) -> bool {
    is_exposed_in(aObj, InterfaceObjectMap::Globals::WINDOW) &&
    PREFS.get("dom.webgl2.enabled").as_boolean().unwrap_or(false)
}

unsafe fn CreateInterfaceObjects<TH: TypeHolderTrait>
(cx: *mut JSContext, global: HandleObject, cache: *mut ProtoOrIfaceArray) {
    rooted!(in(cx) let mut prototype_proto = ptr::null_mut::<JSObject>());
    prototype_proto.set(JS_GetObjectPrototype(cx, global));
    assert!(!prototype_proto.is_null());

    rooted!(in(cx) let mut prototype = ptr::null_mut::<JSObject>());
    create_interface_prototype_object(cx,
                                      prototype_proto.handle().into(),
                                      &PrototypeClass,
                                      sMethods::<TH>(),
                                      sAttributes::<TH>(),
                                      sConstants,
                                      &[],
                                      prototype.handle_mut().into());
    assert!(!prototype.is_null());
    assert!((*cache)[PrototypeList::ID::WebGL2RenderingContext as usize].is_null());
    (*cache)[PrototypeList::ID::WebGL2RenderingContext as usize] = prototype.get();
    <*mut JSObject>::post_barrier((*cache).as_mut_ptr().offset(PrototypeList::ID::WebGL2RenderingContext as isize),
                                  ptr::null_mut(),
                                  prototype.get());


    rooted!(in(cx) let interface_proto = JS_GetFunctionPrototype(cx, global));
    assert!(!interface_proto.is_null());

    rooted!(in(cx) let mut interface = ptr::null_mut::<JSObject>());
    create_noncallback_interface_object(cx,
                                        global.into(),
                                        interface_proto.handle(),
                                        &INTERFACE_OBJECT_CLASS,
                                        &[],
                                        &[],
                                        sConstants,
                                        prototype.handle(),
                                        b"WebGL2RenderingContext\0",
                                        0,
                                        interface.handle_mut());
    assert!(!interface.is_null());
}
} // mod WebGL2RenderingContextBinding


